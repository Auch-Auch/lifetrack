package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/aleksandr/lifetrack/backend/auth"
	"github.com/aleksandr/lifetrack/backend/graph/model"
	"github.com/google/uuid"
	"github.com/lib/pq"
)

// Skills is the resolver for the skills field.
func (r *learningPlanResolver) Skills(ctx context.Context, obj *model.LearningPlan) ([]*model.Skill, error) {
	if len(obj.SkillIds) == 0 {
		return []*model.Skill{}, nil
	}

	// Convert skill IDs to strings for the query
	skillIDStrs := make([]string, len(obj.SkillIds))
	for i, id := range obj.SkillIds {
		skillIDStrs[i] = id.String()
	}

	var skills []*model.Skill
	query := `
		SELECT id, user_id, name, level, notes, created_at, updated_at
		FROM skills
		WHERE id = ANY($1)
		ORDER BY name ASC
	`
	err := r.DB.Select(&skills, query, pq.Array(skillIDStrs))
	if err != nil {
		return nil, fmt.Errorf("failed to fetch skills: %w", err)
	}

	return skills, nil
}

// Nodes is the resolver for the nodes field.
func (r *learningPlanResolver) Nodes(ctx context.Context, obj *model.LearningPlan) ([]*model.LearningPlanNode, error) {
	var nodes []*model.LearningPlanNode
	err := r.DB.Select(&nodes, `
		SELECT id, learning_plan_id, skill_id, title, description,
		       planned_hours, completed_hours, position_x, position_y,
		       created_at, updated_at
		FROM learning_plan_nodes
		WHERE learning_plan_id = $1
		ORDER BY created_at ASC
	`, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch learning plan nodes: %w", err)
	}

	// Fetch skills for nodes that have skill_id set
	for _, node := range nodes {
		if node.SkillID != nil {
			var skill model.Skill
			err = r.DB.Get(&skill, `
				SELECT id, user_id, name, level, notes, created_at, updated_at
				FROM skills WHERE id = $1
			`, *node.SkillID)
			if err == nil {
				node.Skill = &skill
			}
		}
	}

	return nodes, nil
}

// Edges is the resolver for the edges field.
func (r *learningPlanResolver) Edges(ctx context.Context, obj *model.LearningPlan) ([]*model.LearningPlanEdge, error) {
	var edges []*model.LearningPlanEdge
	err := r.DB.Select(&edges, `
		SELECT id, learning_plan_id, source_node_id, target_node_id, created_at
		FROM learning_plan_edges
		WHERE learning_plan_id = $1
		ORDER BY created_at ASC
	`, obj.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch learning plan edges: %w", err)
	}

	return edges, nil
}

// Register creates a new user account
func (r *mutationResolver) Register(ctx context.Context, email string, password string, name string) (*model.AuthPayload, error) {
	// Validate email format
	email = strings.TrimSpace(strings.ToLower(email))
	if email == "" || !strings.Contains(email, "@") {
		return nil, fmt.Errorf("invalid email address")
	}

	// Check if email already exists
	var existingUserID uuid.UUID
	err := r.DB.Get(&existingUserID, "SELECT id FROM users WHERE email = $1", email)
	if err == nil {
		return nil, fmt.Errorf("user with email %s already exists", email)
	}

	// Hash password
	passwordHash, err := r.Auth.HashPassword(password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// Insert user into database
	userID := uuid.New()
	now := time.Now()

	_, err = r.DB.Exec(`
		INSERT INTO users (id, email, name, password_hash, is_service, is_active, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
	`, userID, email, name, passwordHash, false, true, now, now)
	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// Generate token
	token, err := r.Auth.GenerateTokenWithFlags(userID.String(), email, name, false)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:        userID,
			Email:     email,
			Name:      name,
			IsService: false,
			IsActive:  true,
		},
	}, nil
}

// Login authenticates a user
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	// Normalize email
	email = strings.TrimSpace(strings.ToLower(email))

	// Query user by email
	var user struct {
		ID           uuid.UUID `db:"id"`
		Email        string    `db:"email"`
		Name         string    `db:"name"`
		PasswordHash string    `db:"password_hash"`
		IsService    bool      `db:"is_service"`
		IsActive     bool      `db:"is_active"`
	}

	err := r.DB.Get(&user, "SELECT id, email, name, password_hash, is_service, is_active FROM users WHERE email = $1", email)
	if err != nil {
		return nil, fmt.Errorf("invalid email or password")
	}

	// Check if user is active
	if !user.IsActive {
		return nil, fmt.Errorf("account is inactive")
	}

	// Check password
	if !r.Auth.CheckPassword(password, user.PasswordHash) {
		return nil, fmt.Errorf("invalid email or password")
	}

	// Generate token
	token, err := r.Auth.GenerateTokenWithFlags(user.ID.String(), user.Email, user.Name, user.IsService)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token: %w", err)
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:        user.ID,
			Email:     user.Email,
			Name:      user.Name,
			IsService: user.IsService,
			IsActive:  user.IsActive,
		},
	}, nil
}

// LinkTelegram links a Telegram account to the authenticated user
func (r *mutationResolver) LinkTelegram(ctx context.Context, telegramID int, telegramUsername *string) (*model.User, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Check if telegram ID is already linked to another user
	var existingUserID uuid.UUID
	err = r.DB.Get(&existingUserID, `SELECT id FROM users WHERE telegram_id = $1 AND id != $2`, telegramID, userID)
	if err == nil {
		return nil, fmt.Errorf("this Telegram account is already linked to another user")
	}

	// Update user with telegram ID
	now := time.Now()
	_, err = r.DB.Exec(`
		UPDATE users 
		SET telegram_id = $1, updated_at = $2
		WHERE id = $3
	`, telegramID, now, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to link Telegram account: %w", err)
	}

	// Fetch updated user
	var updatedUser model.User
	err = r.DB.Get(&updatedUser, `
		SELECT id, email, name, telegram_id, is_service, is_active, created_at, updated_at
		FROM users
		WHERE id = $1
	`, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated user: %w", err)
	}

	return &updatedUser, nil
}

// CreateSkill creates a new skill
func (r *mutationResolver) CreateSkill(ctx context.Context, input model.CreateSkillInput) (*model.Skill, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Check if skill with this name already exists for this user
	var existingSkillID uuid.UUID
	err = r.DB.Get(&existingSkillID, `
		SELECT id FROM skills 
		WHERE user_id = $1 AND LOWER(name) = LOWER($2)
		LIMIT 1
	`, userID, input.Name)
	if err == nil {
		return nil, fmt.Errorf("skill with name '%s' already exists", input.Name)
	}

	skillID := uuid.New()
	now := time.Now()

	// Insert skill
	query := `
		INSERT INTO skills (
			id, user_id, name, level, notes, created_at, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7)
	`
	_, err = r.DB.Exec(query, skillID, userID, input.Name, input.Level, input.Notes, now, now)
	if err != nil {
		return nil, fmt.Errorf("failed to create skill: %w", err)
	}

	// Fetch created skill
	var skill model.Skill
	err = r.DB.Get(&skill, `
		SELECT 
			id,
			user_id,
			name,
			level,
			notes,
			created_at,
			updated_at
		FROM skills WHERE id = $1
	`, skillID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch created skill: %w", err)
	}

	return &skill, nil
}

// UpdateSkill is the resolver for the updateSkill field.
func (r *mutationResolver) UpdateSkill(ctx context.Context, id uuid.UUID, input model.UpdateSkillInput) (*model.Skill, error) {
	panic(fmt.Errorf("not implemented: UpdateSkill - updateSkill"))
}

// DeleteSkill is the resolver for the deleteSkill field.
func (r *mutationResolver) DeleteSkill(ctx context.Context, id uuid.UUID) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteSkill - deleteSkill"))
}

// CreateActivity creates a new activity
func (r *mutationResolver) CreateActivity(ctx context.Context, input model.CreateActivityInput) (*model.Activity, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	activityID := uuid.New()
	now := time.Now()

	// Convert enum to lowercase for database
	status := strings.ToLower(string(input.Status))

	// Insert activity
	query := `
		INSERT INTO activities (
			id, user_id, skill_id, name, duration, date, notes, status, created_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
	`
	_, err = r.DB.Exec(query, activityID, userID, input.SkillID, input.Name,
		input.Duration, input.Date, input.Notes, status, now)
	if err != nil {
		return nil, fmt.Errorf("failed to create activity: %w", err)
	}

	// Fetch created activity
	var activity model.Activity
	err = r.DB.Get(&activity, `
		SELECT 
			id,
			user_id,
			skill_id,
			name,
			duration,
			date,
			notes,
			status,
			started_at,
			created_at
		FROM activities WHERE id = $1
	`, activityID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch created activity: %w", err)
	}

	// Fetch associated skill
	var skill model.Skill
	err = r.DB.Get(&skill, `
		SELECT 
			id,
			user_id,
			name,
			level,
			notes,
			created_at,
			updated_at
		FROM skills WHERE id = $1
	`, input.SkillID)
	if err == nil {
		activity.Skill = &skill
	}

	return &activity, nil
}

// UpdateActivity is the resolver for the updateActivity field.
func (r *mutationResolver) UpdateActivity(ctx context.Context, id uuid.UUID, input model.UpdateActivityInput) (*model.Activity, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Verify the activity belongs to the user
	var ownerID uuid.UUID
	err = r.DB.Get(&ownerID, "SELECT user_id FROM activities WHERE id = $1", id)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("activity not found")
		}
		return nil, fmt.Errorf("failed to verify activity ownership: %w", err)
	}

	if ownerID != userID {
		return nil, fmt.Errorf("unauthorized: activity does not belong to user")
	}

	// Build dynamic update query based on provided fields
	updateFields := []string{}
	updateValues := []interface{}{}
	paramIndex := 1

	if input.Name != nil {
		updateFields = append(updateFields, fmt.Sprintf("name = $%d", paramIndex))
		updateValues = append(updateValues, *input.Name)
		paramIndex++
	}

	if input.Duration != nil {
		updateFields = append(updateFields, fmt.Sprintf("duration = $%d", paramIndex))
		updateValues = append(updateValues, *input.Duration)
		paramIndex++
	}

	if input.Date != nil {
		updateFields = append(updateFields, fmt.Sprintf("date = $%d", paramIndex))
		updateValues = append(updateValues, *input.Date)
		paramIndex++
	}

	if input.Notes != nil {
		updateFields = append(updateFields, fmt.Sprintf("notes = $%d", paramIndex))
		updateValues = append(updateValues, *input.Notes)
		paramIndex++
	}

	if input.Status != nil {
		status := strings.ToLower(string(*input.Status))
		updateFields = append(updateFields, fmt.Sprintf("status = $%d", paramIndex))
		updateValues = append(updateValues, status)
		paramIndex++
	}

	if len(updateFields) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	// Add the ID to the values for the WHERE clause
	updateValues = append(updateValues, id)

	// Execute update
	query := fmt.Sprintf("UPDATE activities SET %s WHERE id = $%d",
		strings.Join(updateFields, ", "),
		paramIndex)

	_, err = r.DB.Exec(query, updateValues...)
	if err != nil {
		return nil, fmt.Errorf("failed to update activity: %w", err)
	}

	// Fetch updated activity
	var activity model.Activity
	err = r.DB.Get(&activity, `
		SELECT 
			id,
			user_id,
			skill_id,
			name,
			duration,
			date,
			notes,
			status,
			started_at,
			paused_at,
			paused_duration,
			created_at
		FROM activities WHERE id = $1
	`, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated activity: %w", err)
	}

	// Fetch associated skill
	var skill model.Skill
	err = r.DB.Get(&skill, `
		SELECT 
			id,
			user_id,
			name,
			level,
			notes,
			created_at,
			updated_at
		FROM skills WHERE id = $1
	`, activity.SkillID)
	if err == nil {
		activity.Skill = &skill
	}

	return &activity, nil
}

// DeleteActivity is the resolver for the deleteActivity field.
func (r *mutationResolver) DeleteActivity(ctx context.Context, id uuid.UUID) (bool, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return false, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	// Verify the activity belongs to the user
	var ownerID uuid.UUID
	err = r.DB.Get(&ownerID, "SELECT user_id FROM activities WHERE id = $1", id)
	if err != nil {
		if err == sql.ErrNoRows {
			return false, fmt.Errorf("activity not found")
		}
		return false, fmt.Errorf("failed to verify activity ownership: %w", err)
	}

	if ownerID != userID {
		return false, fmt.Errorf("unauthorized: activity does not belong to user")
	}

	// Delete the activity
	result, err := r.DB.Exec("DELETE FROM activities WHERE id = $1", id)
	if err != nil {
		return false, fmt.Errorf("failed to delete activity: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return false, fmt.Errorf("activity not found")
	}

	return true, nil
}

// StartSession starts a new activity session
func (r *mutationResolver) StartSession(ctx context.Context, skillID uuid.UUID, name string) (*model.Activity, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Check if user already has an active session
	var existingSessionID uuid.UUID
	err = r.DB.Get(&existingSessionID, `
		SELECT id FROM activities 
		WHERE user_id = $1 AND status = 'ACTIVE'
		LIMIT 1
	`, userID)
	if err == nil {
		return nil, fmt.Errorf("you already have an active session")
	}

	// Create new activity with status='ACTIVE'
	now := time.Now()
	today := now.Format("2006-01-02")
	activityID := uuid.New()

	query := `
		INSERT INTO activities (
			id, user_id, skill_id, name, duration, date, 
			status, started_at, created_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
	`
	_, err = r.DB.Exec(query, activityID, userID, skillID, name, 0, today, "ACTIVE", now, now)
	if err != nil {
		return nil, fmt.Errorf("failed to start session: %w", err)
	}

	// Fetch the created activity with skill info
	var activity model.Activity
	var skill model.Skill
	err = r.DB.Get(&struct {
		ActivityID        uuid.UUID  `db:"activity_id"`
		ActivityUserID    uuid.UUID  `db:"activity_user_id"`
		ActivitySkillID   uuid.UUID  `db:"activity_skill_id"`
		ActivityName      string     `db:"activity_name"`
		ActivityDuration  int        `db:"activity_duration"`
		ActivityDate      time.Time  `db:"activity_date"`
		ActivityStatus    string     `db:"activity_status"`
		ActivityStartedAt *time.Time `db:"activity_started_at"`
		ActivityCreatedAt time.Time  `db:"activity_created_at"`
		SkillID           uuid.UUID  `db:"skill_id"`
		SkillUserID       uuid.UUID  `db:"skill_user_id"`
		SkillName         string     `db:"skill_name"`
		SkillLevel        *string    `db:"skill_level"`
		SkillNotes        *string    `db:"skill_notes"`
		SkillCreatedAt    time.Time  `db:"skill_created_at"`
		SkillUpdatedAt    time.Time  `db:"skill_updated_at"`
	}{
		ActivityID:        activityID,
		ActivityUserID:    userID,
		ActivitySkillID:   skillID,
		ActivityName:      name,
		ActivityDuration:  0,
		ActivityDate:      now,
		ActivityStatus:    "ACTIVE",
		ActivityStartedAt: &now,
		ActivityCreatedAt: now,
	}, `
		SELECT 
			a.id as activity_id, a.user_id as activity_user_id, a.skill_id as activity_skill_id,
			a.name as activity_name, a.duration as activity_duration, a.date as activity_date,
			a.status as activity_status, a.started_at as activity_started_at, a.created_at as activity_created_at,
			s.id as skill_id, s.user_id as skill_user_id, s.name as skill_name,
			s.level as skill_level, s.notes as skill_notes, s.created_at as skill_created_at,
			s.updated_at as skill_updated_at
		FROM activities a
		JOIN skills s ON a.skill_id = s.id
		WHERE a.id = $1
	`, activityID)

	if err != nil {
		return nil, fmt.Errorf("failed to fetch created activity: %w", err)
	}

	// Since we just created it, we can construct the response
	activity = model.Activity{
		ID:        activityID,
		UserID:    userID,
		SkillID:   skillID,
		Name:      name,
		Duration:  0,
		Date:      now,
		Status:    model.ActivityStatusActive,
		StartedAt: &now,
		CreatedAt: now,
	}

	// Fetch skill separately
	err = r.DB.Get(&skill, `
		SELECT 
			id,
			user_id,
			name,
			level,
			notes,
			created_at,
			updated_at
		FROM skills WHERE id = $1
	`, skillID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch skill: %w", err)
	}

	activity.Skill = &skill

	return &activity, nil
}

// PauseSession is the resolver for the pauseSession field.
func (r *mutationResolver) PauseSession(ctx context.Context, id uuid.UUID) (*model.Activity, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Fetch activity and verify it's active and owned by user
	var activity struct {
		ID     uuid.UUID `db:"id"`
		UserID uuid.UUID `db:"user_id"`
		Status string    `db:"status"`
	}
	err = r.DB.Get(&activity, `SELECT id, user_id, status FROM activities WHERE id = $1`, id)
	if err != nil {
		return nil, fmt.Errorf("activity not found: %w", err)
	}

	if activity.UserID != userID {
		return nil, fmt.Errorf("unauthorized")
	}

	if activity.Status != "ACTIVE" {
		return nil, fmt.Errorf("session is not active")
	}

	// Update to paused status
	now := time.Now()
	_, err = r.DB.Exec(`
		UPDATE activities SET status = 'PAUSED', paused_at = $1 WHERE id = $2
	`, now, id)
	if err != nil {
		return nil, fmt.Errorf("failed to pause session: %w", err)
	}

	// Fetch and return updated activity
	var result model.Activity
	err = r.DB.Get(&result, `
		SELECT 
			id,
			user_id,
			skill_id,
			name,
			duration,
			date,
			notes,
			status,
			started_at,
			paused_at,
			paused_duration,
			created_at
		FROM activities WHERE id = $1
	`, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch activity: %w", err)
	}

	result.Status = model.ActivityStatusPaused
	return &result, nil
}

// ResumeSession is the resolver for the resumeSession field.
func (r *mutationResolver) ResumeSession(ctx context.Context, id uuid.UUID) (*model.Activity, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Fetch activity
	var activity struct {
		ID             uuid.UUID  `db:"id"`
		UserID         uuid.UUID  `db:"user_id"`
		Status         string     `db:"status"`
		PausedAt       *time.Time `db:"paused_at"`
		PausedDuration *int64     `db:"paused_duration"`
	}
	err = r.DB.Get(&activity, `
		SELECT id, user_id, status, paused_at, paused_duration 
		FROM activities WHERE id = $1
	`, id)
	if err != nil {
		return nil, fmt.Errorf("activity not found: %w", err)
	}

	if activity.UserID != userID {
		return nil, fmt.Errorf("unauthorized")
	}

	if activity.Status != "PAUSED" {
		return nil, fmt.Errorf("session is not paused")
	}

	// Calculate accumulated paused duration
	var newPausedDuration int64
	if activity.PausedAt != nil {
		pauseDuration := time.Since(*activity.PausedAt).Milliseconds()
		if activity.PausedDuration != nil {
			newPausedDuration = *activity.PausedDuration + pauseDuration
		} else {
			newPausedDuration = pauseDuration
		}
	}

	// Resume session
	_, err = r.DB.Exec(`
		UPDATE activities 
		SET status = 'ACTIVE', paused_at = NULL, paused_duration = $1 
		WHERE id = $2
	`, newPausedDuration, id)
	if err != nil {
		return nil, fmt.Errorf("failed to resume session: %w", err)
	}

	// Fetch and return updated activity
	var result model.Activity
	err = r.DB.Get(&result, `
		SELECT 
			id,
			user_id,
			skill_id,
			name,
			duration,
			date,
			notes,
			status,
			started_at,
			paused_at,
			paused_duration,
			created_at
		FROM activities WHERE id = $1
	`, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch activity: %w", err)
	}

	result.Status = model.ActivityStatusActive
	return &result, nil
}

// StopSession is the resolver for the stopSession field.
func (r *mutationResolver) StopSession(ctx context.Context, id uuid.UUID, notes *string) (*model.Activity, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Fetch the activity and verify ownership
	var activity struct {
		ID             uuid.UUID  `db:"id"`
		UserID         uuid.UUID  `db:"user_id"`
		SkillID        uuid.UUID  `db:"skill_id"`
		Name           string     `db:"name"`
		Status         string     `db:"status"`
		StartedAt      *time.Time `db:"started_at"`
		PausedAt       *time.Time `db:"paused_at"`
		PausedDuration *int64     `db:"paused_duration"`
	}
	err = r.DB.Get(&activity, `
		SELECT id, user_id, skill_id, name, status, started_at, paused_at, paused_duration
		FROM activities WHERE id = $1
	`, id)
	if err != nil {
		return nil, fmt.Errorf("activity not found: %w", err)
	}

	if activity.UserID != userID {
		return nil, fmt.Errorf("unauthorized: you cannot stop someone else's session")
	}

	if activity.Status != "ACTIVE" && activity.Status != "PAUSED" {
		return nil, fmt.Errorf("session is not active or paused")
	}

	// Calculate duration
	var duration int // in minutes
	if activity.StartedAt != nil {
		now := time.Now()
		elapsed := now.Sub(*activity.StartedAt)

		// Subtract paused duration if any
		if activity.PausedDuration != nil {
			elapsed -= time.Duration(*activity.PausedDuration) * time.Millisecond
		}

		// If currently paused, subtract time since pause
		if activity.Status == "PAUSED" && activity.PausedAt != nil {
			elapsed -= now.Sub(*activity.PausedAt)
		}

		duration = int(elapsed.Minutes())
		if duration < 0 {
			duration = 0
		}
	}

	// Update activity status to completed
	query := `
		UPDATE activities 
		SET status = 'COMPLETED', duration = $1, notes = COALESCE($2, notes)
		WHERE id = $3
	`
	_, err = r.DB.Exec(query, duration, notes, id)
	if err != nil {
		return nil, fmt.Errorf("failed to stop session: %w", err)
	}

	// Fetch updated activity with skill
	var result model.Activity
	var skill model.Skill

	err = r.DB.Get(&result, `
		SELECT 
			id,
			user_id,
			skill_id,
			name,
			duration,
			date,
			notes,
			status,
			started_at,
			created_at
		FROM activities WHERE id = $1
	`, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated activity: %w", err)
	}

	err = r.DB.Get(&skill, `
		SELECT 
			id,
			user_id,
			name,
			level,
			notes,
			created_at,
			updated_at
		FROM skills WHERE id = $1
	`, result.SkillID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch skill: %w", err)
	}

	result.Skill = &skill
	result.Status = model.ActivityStatusCompleted

	return &result, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.CreateEventInput) (*model.Event, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	eventID := uuid.New()
	now := time.Now()

	// Set defaults
	allDay := false
	if input.AllDay != nil {
		allDay = *input.AllDay
	}

	recurrence := model.RecurrenceNone
	if input.Recurrence != nil {
		recurrence = *input.Recurrence
	}

	// Convert enums to lowercase strings for database
	eventType := strings.ToLower(string(input.Type))
	recurrenceStr := strings.ToLower(string(recurrence))

	// Convert notifications to JSONB
	var notificationsJSON interface{}
	if input.Notifications != nil {
		notifData := map[string]interface{}{
			"enabled":         input.Notifications.Enabled,
			"channels":        input.Notifications.Channels,
			"reminderMinutes": input.Notifications.ReminderMinutes,
		}
		jsonBytes, err := json.Marshal(notifData)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal notifications: %w", err)
		}
		notificationsJSON = jsonBytes
	} else {
		notificationsJSON = nil
	}

	// Insert event
	query := `
		INSERT INTO events (
			id, user_id, title, description, type, start_time, end_time, all_day,
			recurrence, recurrence_rule, recurrence_end, skill_id, activity_id, 
			learning_plan_id, notifications, color, location, attendees, tags,
			created_at, updated_at
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21
		)
	`

	_, err = r.DB.Exec(
		query,
		eventID, userID, input.Title, input.Description, eventType,
		input.StartTime, input.EndTime, allDay, recurrenceStr, input.RecurrenceRule,
		input.RecurrenceEnd, input.SkillID, input.ActivityID, input.LearningPlanID,
		notificationsJSON, input.Color, input.Location, pq.Array(input.Attendees), pq.Array(input.Tags),
		now, now,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create event: %w", err)
	}

	// Construct the event response from the input values
	attendees := input.Attendees
	if attendees == nil {
		attendees = []string{}
	}
	tags := input.Tags
	if tags == nil {
		tags = []string{}
	}

	event := &model.Event{
		ID:             eventID,
		UserID:         userID,
		Title:          input.Title,
		Description:    input.Description,
		Type:           input.Type,
		StartTime:      input.StartTime,
		EndTime:        input.EndTime,
		AllDay:         allDay,
		Recurrence:     recurrence,
		RecurrenceRule: input.RecurrenceRule,
		RecurrenceEnd:  input.RecurrenceEnd,
		SkillID:        input.SkillID,
		ActivityID:     input.ActivityID,
		LearningPlanID: input.LearningPlanID,
		Color:          input.Color,
		Location:       input.Location,
		Attendees:      attendees,
		Tags:           tags,
		CreatedAt:      now,
		UpdatedAt:      now,
	}

	// Handle notifications field
	if input.Notifications != nil {
		event.Notifications = &model.EventNotifications{
			Enabled:         input.Notifications.Enabled,
			Channels:        input.Notifications.Channels,
			ReminderMinutes: input.Notifications.ReminderMinutes,
		}
	}

	return event, nil
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, id uuid.UUID, input model.UpdateEventInput) (*model.Event, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	now := time.Now()

	// Build dynamic update query
	updateFields := []string{}
	args := []interface{}{id, userID}
	argIdx := 3

	if input.Title != nil {
		updateFields = append(updateFields, fmt.Sprintf("title = $%d", argIdx))
		args = append(args, *input.Title)
		argIdx++
	}

	if input.Description != nil {
		updateFields = append(updateFields, fmt.Sprintf("description = $%d", argIdx))
		args = append(args, *input.Description)
		argIdx++
	}

	if input.Type != nil {
		updateFields = append(updateFields, fmt.Sprintf("type = $%d", argIdx))
		args = append(args, strings.ToLower(string(*input.Type)))
		argIdx++
	}

	if input.StartTime != nil {
		updateFields = append(updateFields, fmt.Sprintf("start_time = $%d", argIdx))
		args = append(args, *input.StartTime)
		argIdx++
	}

	if input.EndTime != nil {
		updateFields = append(updateFields, fmt.Sprintf("end_time = $%d", argIdx))
		args = append(args, *input.EndTime)
		argIdx++
	}

	if input.AllDay != nil {
		updateFields = append(updateFields, fmt.Sprintf("all_day = $%d", argIdx))
		args = append(args, *input.AllDay)
		argIdx++
	}

	if input.Recurrence != nil {
		updateFields = append(updateFields, fmt.Sprintf("recurrence = $%d", argIdx))
		args = append(args, strings.ToLower(string(*input.Recurrence)))
		argIdx++
	}

	if input.RecurrenceRule != nil {
		updateFields = append(updateFields, fmt.Sprintf("recurrence_rule = $%d", argIdx))
		args = append(args, *input.RecurrenceRule)
		argIdx++
	}

	if input.Color != nil {
		updateFields = append(updateFields, fmt.Sprintf("color = $%d", argIdx))
		args = append(args, *input.Color)
		argIdx++
	}

	if input.Location != nil {
		updateFields = append(updateFields, fmt.Sprintf("location = $%d", argIdx))
		args = append(args, *input.Location)
		argIdx++
	}

	if input.Attendees != nil {
		updateFields = append(updateFields, fmt.Sprintf("attendees = $%d", argIdx))
		args = append(args, pq.Array(input.Attendees))
		argIdx++
	}

	if input.Tags != nil {
		updateFields = append(updateFields, fmt.Sprintf("tags = $%d", argIdx))
		args = append(args, pq.Array(input.Tags))
		argIdx++
	}

	if input.Notifications != nil {
		notifData := map[string]interface{}{
			"enabled":         input.Notifications.Enabled,
			"channels":        input.Notifications.Channels,
			"reminderMinutes": input.Notifications.ReminderMinutes,
		}
		notificationsJSON, err := json.Marshal(notifData)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal notifications: %w", err)
		}
		updateFields = append(updateFields, fmt.Sprintf("notifications = $%d", argIdx))
		args = append(args, notificationsJSON)
		argIdx++
	}

	if len(updateFields) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	// Add updated_at
	updateFields = append(updateFields, fmt.Sprintf("updated_at = $%d", argIdx))
	args = append(args, now)

	query := fmt.Sprintf(`
		UPDATE events
		SET %s
		WHERE id = $1 AND user_id = $2
	`, strings.Join(updateFields, ", "))

	result, err := r.DB.Exec(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to update event: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return nil, fmt.Errorf("event not found or unauthorized")
	}

	// Fetch updated event
	var event model.Event
	var eventType string
	var recurrence string
	var attendees []string
	var tags []string

	err = r.DB.QueryRow(`
		SELECT id, user_id, title, description, type, start_time, end_time,
		       all_day, recurrence, recurrence_rule, recurrence_end,
		       skill_id, activity_id, learning_plan_id, color, location,
		       COALESCE(attendees, '{}'), COALESCE(tags, '{}'), created_at, updated_at
		FROM events
		WHERE id = $1
	`, id).Scan(
		&event.ID,
		&event.UserID,
		&event.Title,
		&event.Description,
		&eventType,
		&event.StartTime,
		&event.EndTime,
		&event.AllDay,
		&recurrence,
		&event.RecurrenceRule,
		&event.RecurrenceEnd,
		&event.SkillID,
		&event.ActivityID,
		&event.LearningPlanID,
		&event.Color,
		&event.Location,
		pq.Array(&attendees),
		pq.Array(&tags),
		&event.CreatedAt,
		&event.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated event: %w", err)
	}

	// Convert lowercase database values to uppercase enum types
	event.Type = model.EventType(strings.ToUpper(eventType))
	event.Recurrence = model.Recurrence(strings.ToUpper(recurrence))
	event.Attendees = attendees
	event.Tags = tags

	return &event, nil
}

// DeleteEvent is the resolver for the deleteEvent field.
func (r *mutationResolver) DeleteEvent(ctx context.Context, id uuid.UUID) (bool, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return false, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	query := `DELETE FROM events WHERE id = $1 AND user_id = $2`
	result, err := r.DB.Exec(query, id, userID)
	if err != nil {
		return false, fmt.Errorf("failed to delete event: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return false, fmt.Errorf("event not found or unauthorized")
	}

	return true, nil
}

// CreateLearningPlan is the resolver for the createLearningPlan field.
func (r *mutationResolver) CreateLearningPlan(ctx context.Context, input model.CreateLearningPlanInput) (*model.LearningPlan, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	planID := uuid.New()
	now := time.Now()

	// Marshal schedule to JSONB
	scheduleJSON, err := json.Marshal(input.Schedule)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal schedule: %w", err)
	}

	// Convert UUID slice to string slice for pq.Array
	skillIDStrs := make([]string, len(input.SkillIds))
	for i, id := range input.SkillIds {
		skillIDStrs[i] = id.String()
	}

	// Insert learning plan
	query := `
		INSERT INTO learning_plans (
			id, user_id, name, description, skill_ids, schedule, 
			target_hours_per_week, start_date, end_date, completed_hours,
			created_at, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
	`

	_, err = r.DB.Exec(
		query,
		planID, userID, input.Name, input.Description, pq.Array(skillIDStrs),
		scheduleJSON, input.TargetHoursPerWeek, input.StartDate, input.EndDate, 0,
		now, now,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create learning plan: %w", err)
	}

	// Convert ScheduleInput to Schedule
	schedule := &model.Schedule{
		Frequency:       input.Schedule.Frequency,
		DurationMinutes: input.Schedule.DurationMinutes,
		PreferredTimes:  input.Schedule.PreferredTimes,
		PreferredDays:   input.Schedule.PreferredDays,
		AutoSchedule:    input.Schedule.AutoSchedule,
	}

	// Create the response object
	plan := &model.LearningPlan{
		ID:                 planID,
		UserID:             userID,
		Name:               input.Name,
		Description:        input.Description,
		SkillIds:           input.SkillIds,
		Skills:             []*model.Skill{},
		Schedule:           schedule,
		TargetHoursPerWeek: input.TargetHoursPerWeek,
		StartDate:          input.StartDate,
		EndDate:            input.EndDate,
		CompletedHours:     0,
		Nodes:              []*model.LearningPlanNode{},
		Edges:              []*model.LearningPlanEdge{},
		CreatedAt:          now,
		UpdatedAt:          now,
	}

	return plan, nil
}

// UpdateLearningPlan is the resolver for the updateLearningPlan field.
func (r *mutationResolver) UpdateLearningPlan(ctx context.Context, id uuid.UUID, input model.UpdateLearningPlanInput) (*model.LearningPlan, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Check authorization - verify plan belongs to user
	var planOwner uuid.UUID
	err = r.DB.Get(&planOwner, "SELECT user_id FROM learning_plans WHERE id = $1", id)
	if err != nil {
		return nil, fmt.Errorf("learning plan not found")
	}
	if planOwner != userID {
		return nil, fmt.Errorf("unauthorized: plan belongs to another user")
	}

	// Build dynamic update query
	updateFields := []string{}
	args := []interface{}{}
	paramIdx := 1

	if input.Name != nil {
		updateFields = append(updateFields, fmt.Sprintf("name = $%d", paramIdx))
		args = append(args, *input.Name)
		paramIdx++
	}

	if input.Description != nil {
		updateFields = append(updateFields, fmt.Sprintf("description = $%d", paramIdx))
		args = append(args, *input.Description)
		paramIdx++
	}

	if input.SkillIds != nil {
		skillIDStrs := make([]string, len(input.SkillIds))
		for i, skillID := range input.SkillIds {
			skillIDStrs[i] = skillID.String()
		}
		updateFields = append(updateFields, fmt.Sprintf("skill_ids = $%d", paramIdx))
		args = append(args, pq.Array(skillIDStrs))
		paramIdx++
	}

	if input.Schedule != nil {
		scheduleJSON, err := json.Marshal(input.Schedule)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal schedule: %w", err)
		}
		updateFields = append(updateFields, fmt.Sprintf("schedule = $%d", paramIdx))
		args = append(args, scheduleJSON)
		paramIdx++
	}

	if input.TargetHoursPerWeek != nil {
		updateFields = append(updateFields, fmt.Sprintf("target_hours_per_week = $%d", paramIdx))
		args = append(args, *input.TargetHoursPerWeek)
		paramIdx++
	}

	if input.StartDate != nil {
		updateFields = append(updateFields, fmt.Sprintf("start_date = $%d", paramIdx))
		args = append(args, *input.StartDate)
		paramIdx++
	}

	if input.EndDate != nil {
		updateFields = append(updateFields, fmt.Sprintf("end_date = $%d", paramIdx))
		args = append(args, *input.EndDate)
		paramIdx++
	}

	if len(updateFields) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	// Add updated_at
	updateFields = append(updateFields, fmt.Sprintf("updated_at = $%d", paramIdx))
	args = append(args, time.Now())
	paramIdx++

	// Add ID for WHERE clause
	args = append(args, id)

	query := fmt.Sprintf(
		"UPDATE learning_plans SET %s WHERE id = $%d",
		strings.Join(updateFields, ", "),
		paramIdx,
	)

	_, err = r.DB.Exec(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to update learning plan: %w", err)
	}

	// Fetch and return updated plan
	type dbLearningPlan struct {
		ID                 uuid.UUID      `db:"id"`
		UserID             uuid.UUID      `db:"user_id"`
		Name               string         `db:"name"`
		Description        *string        `db:"description"`
		SkillIDs           pq.StringArray `db:"skill_ids"`
		ScheduleJSON       []byte         `db:"schedule"`
		TargetHoursPerWeek *float64       `db:"target_hours_per_week"`
		StartDate          time.Time      `db:"start_date"`
		EndDate            *time.Time     `db:"end_date"`
		CompletedHours     float64        `db:"completed_hours"`
		CreatedAt          time.Time      `db:"created_at"`
		UpdatedAt          time.Time      `db:"updated_at"`
	}

	var dbPlan dbLearningPlan
	err = r.DB.Get(&dbPlan, `
		SELECT id, user_id, name, description, skill_ids, schedule,
		       target_hours_per_week, start_date, end_date, completed_hours,
		       created_at, updated_at
		FROM learning_plans
		WHERE id = $1
	`, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated learning plan: %w", err)
	}

	// Convert skill IDs from string array to UUID array
	skillIDs := make([]uuid.UUID, len(dbPlan.SkillIDs))
	for i, idStr := range dbPlan.SkillIDs {
		skillIDs[i], _ = uuid.Parse(idStr)
	}

	// Unmarshal schedule
	var schedule model.Schedule
	err = json.Unmarshal(dbPlan.ScheduleJSON, &schedule)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal schedule: %w", err)
	}

	plan := &model.LearningPlan{
		ID:                 dbPlan.ID,
		UserID:             dbPlan.UserID,
		Name:               dbPlan.Name,
		Description:        dbPlan.Description,
		SkillIds:           skillIDs,
		Skills:             []*model.Skill{},
		Schedule:           &schedule,
		TargetHoursPerWeek: dbPlan.TargetHoursPerWeek,
		StartDate:          dbPlan.StartDate,
		EndDate:            dbPlan.EndDate,
		CompletedHours:     dbPlan.CompletedHours,
		Nodes:              []*model.LearningPlanNode{},
		Edges:              []*model.LearningPlanEdge{},
		CreatedAt:          dbPlan.CreatedAt,
		UpdatedAt:          dbPlan.UpdatedAt,
	}

	return plan, nil
}

// DeleteLearningPlan is the resolver for the deleteLearningPlan field.
func (r *mutationResolver) DeleteLearningPlan(ctx context.Context, id uuid.UUID) (bool, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return false, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	// Delete with authorization check
	query := `DELETE FROM learning_plans WHERE id = $1 AND user_id = $2`
	result, err := r.DB.Exec(query, id, userID)
	if err != nil {
		return false, fmt.Errorf("failed to delete learning plan: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return false, fmt.Errorf("learning plan not found or unauthorized")
	}

	return true, nil
}

// GenerateSchedule is the resolver for the generateSchedule field.
func (r *mutationResolver) GenerateSchedule(ctx context.Context, planID uuid.UUID) ([]*model.Event, error) {
	panic(fmt.Errorf("not implemented: GenerateSchedule - generateSchedule"))
}

// CreateLearningPlanNode creates a new node in a learning plan DAG
func (r *mutationResolver) CreateLearningPlanNode(ctx context.Context, input model.CreateLearningPlanNodeInput) (*model.LearningPlanNode, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Verify the learning plan belongs to the user
	var planOwner uuid.UUID
	err = r.DB.Get(&planOwner, "SELECT user_id FROM learning_plans WHERE id = $1", input.LearningPlanID)
	if err != nil {
		return nil, fmt.Errorf("learning plan not found: %w", err)
	}
	if planOwner != userID {
		return nil, fmt.Errorf("unauthorized access to learning plan")
	}

	nodeID := uuid.New()
	now := time.Now()

	query := `
		INSERT INTO learning_plan_nodes (
			id, learning_plan_id, skill_id, title, description,
			planned_hours, completed_hours, position_x, position_y,
			created_at, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
	`

	_, err = r.DB.Exec(query, nodeID, input.LearningPlanID, input.SkillID,
		input.Title, input.Description, input.PlannedHours, 0,
		input.PositionX, input.PositionY, now, now)
	if err != nil {
		return nil, fmt.Errorf("failed to create learning plan node: %w", err)
	}

	node := &model.LearningPlanNode{
		ID:             nodeID,
		LearningPlanID: input.LearningPlanID,
		SkillID:        input.SkillID,
		Title:          input.Title,
		Description:    input.Description,
		PlannedHours:   input.PlannedHours,
		CompletedHours: 0,
		PositionX:      input.PositionX,
		PositionY:      input.PositionY,
		CreatedAt:      now,
		UpdatedAt:      now,
	}

	// If skill_id is provided, fetch the skill
	if input.SkillID != nil {
		var skill model.Skill
		err = r.DB.Get(&skill, `
			SELECT id, user_id, name, level, notes, created_at, updated_at
			FROM skills WHERE id = $1
		`, *input.SkillID)
		if err == nil {
			node.Skill = &skill
		}
	}

	return node, nil
}

// UpdateLearningPlanNode updates a learning plan node
func (r *mutationResolver) UpdateLearningPlanNode(ctx context.Context, id uuid.UUID, input model.UpdateLearningPlanNodeInput) (*model.LearningPlanNode, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Verify access through learning plan ownership
	var planOwner uuid.UUID
	err = r.DB.Get(&planOwner, `
		SELECT lp.user_id FROM learning_plans lp
		JOIN learning_plan_nodes lpn ON lpn.learning_plan_id = lp.id
		WHERE lpn.id = $1
	`, id)
	if err != nil {
		return nil, fmt.Errorf("node not found: %w", err)
	}
	if planOwner != userID {
		return nil, fmt.Errorf("unauthorized access to learning plan node")
	}

	// Build dynamic update query
	updates := []string{}
	args := []interface{}{}
	argIdx := 1

	if input.SkillID != nil {
		updates = append(updates, fmt.Sprintf("skill_id = $%d", argIdx))
		args = append(args, *input.SkillID)
		argIdx++
	}

	if input.Title != nil {
		updates = append(updates, fmt.Sprintf("title = $%d", argIdx))
		args = append(args, *input.Title)
		argIdx++
	}

	if input.Description != nil {
		updates = append(updates, fmt.Sprintf("description = $%d", argIdx))
		args = append(args, *input.Description)
		argIdx++
	}

	if input.PlannedHours != nil {
		updates = append(updates, fmt.Sprintf("planned_hours = $%d", argIdx))
		args = append(args, *input.PlannedHours)
		argIdx++
	}

	if input.CompletedHours != nil {
		updates = append(updates, fmt.Sprintf("completed_hours = $%d", argIdx))
		args = append(args, *input.CompletedHours)
		argIdx++
	}

	if input.PositionX != nil {
		updates = append(updates, fmt.Sprintf("position_x = $%d", argIdx))
		args = append(args, *input.PositionX)
		argIdx++
	}

	if input.PositionY != nil {
		updates = append(updates, fmt.Sprintf("position_y = $%d", argIdx))
		args = append(args, *input.PositionY)
		argIdx++
	}

	if len(updates) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	updates = append(updates, fmt.Sprintf("updated_at = $%d", argIdx))
	args = append(args, time.Now())
	argIdx++

	args = append(args, id)
	query := fmt.Sprintf(`
		UPDATE learning_plan_nodes SET %s
		WHERE id = $%d
	`, strings.Join(updates, ", "), argIdx)

	_, err = r.DB.Exec(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to update node: %w", err)
	}

	// Fetch updated node
	var node model.LearningPlanNode
	err = r.DB.Get(&node, `
		SELECT id, learning_plan_id, skill_id, title, description,
		       planned_hours, completed_hours, position_x, position_y,
		       created_at, updated_at
		FROM learning_plan_nodes WHERE id = $1
	`, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated node: %w", err)
	}

	// Fetch skill if present
	if node.SkillID != nil {
		var skill model.Skill
		err = r.DB.Get(&skill, `
			SELECT id, user_id, name, level, notes, created_at, updated_at
			FROM skills WHERE id = $1
		`, *node.SkillID)
		if err == nil {
			node.Skill = &skill
		}
	}

	return &node, nil
}

// DeleteLearningPlanNode deletes a learning plan node
func (r *mutationResolver) DeleteLearningPlanNode(ctx context.Context, id uuid.UUID) (bool, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return false, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	// Verify access through learning plan ownership
	var planOwner uuid.UUID
	err = r.DB.Get(&planOwner, `
		SELECT lp.user_id FROM learning_plans lp
		JOIN learning_plan_nodes lpn ON lpn.learning_plan_id = lp.id
		WHERE lpn.id = $1
	`, id)
	if err != nil {
		return false, fmt.Errorf("node not found: %w", err)
	}
	if planOwner != userID {
		return false, fmt.Errorf("unauthorized access to learning plan node")
	}

	result, err := r.DB.Exec("DELETE FROM learning_plan_nodes WHERE id = $1", id)
	if err != nil {
		return false, fmt.Errorf("failed to delete node: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	return rowsAffected > 0, nil
}

// CreateLearningPlanEdge creates a new edge/dependency in a learning plan DAG
func (r *mutationResolver) CreateLearningPlanEdge(ctx context.Context, input model.CreateLearningPlanEdgeInput) (*model.LearningPlanEdge, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Verify the learning plan belongs to the user
	var planOwner uuid.UUID
	err = r.DB.Get(&planOwner, "SELECT user_id FROM learning_plans WHERE id = $1", input.LearningPlanID)
	if err != nil {
		return nil, fmt.Errorf("learning plan not found: %w", err)
	}
	if planOwner != userID {
		return nil, fmt.Errorf("unauthorized access to learning plan")
	}

	// Verify both nodes belong to the same learning plan
	var sourceCount, targetCount int
	err = r.DB.Get(&sourceCount, `
		SELECT COUNT(*) FROM learning_plan_nodes
		WHERE id = $1 AND learning_plan_id = $2
	`, input.SourceNodeID, input.LearningPlanID)
	if err != nil || sourceCount == 0 {
		return nil, fmt.Errorf("source node not found in learning plan")
	}

	err = r.DB.Get(&targetCount, `
		SELECT COUNT(*) FROM learning_plan_nodes
		WHERE id = $1 AND learning_plan_id = $2
	`, input.TargetNodeID, input.LearningPlanID)
	if err != nil || targetCount == 0 {
		return nil, fmt.Errorf("target node not found in learning plan")
	}

	edgeID := uuid.New()
	now := time.Now()

	query := `
		INSERT INTO learning_plan_edges (
			id, learning_plan_id, source_node_id, target_node_id, created_at
		) VALUES ($1, $2, $3, $4, $5)
	`

	_, err = r.DB.Exec(query, edgeID, input.LearningPlanID, input.SourceNodeID, input.TargetNodeID, now)
	if err != nil {
		return nil, fmt.Errorf("failed to create learning plan edge: %w", err)
	}

	return &model.LearningPlanEdge{
		ID:             edgeID,
		LearningPlanID: input.LearningPlanID,
		SourceNodeID:   input.SourceNodeID,
		TargetNodeID:   input.TargetNodeID,
		CreatedAt:      now,
	}, nil
}

// DeleteLearningPlanEdge deletes a learning plan edge
func (r *mutationResolver) DeleteLearningPlanEdge(ctx context.Context, id uuid.UUID) (bool, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return false, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	// Verify access through learning plan ownership
	var planOwner uuid.UUID
	err = r.DB.Get(&planOwner, `
		SELECT lp.user_id FROM learning_plans lp
		JOIN learning_plan_edges lpe ON lpe.learning_plan_id = lp.id
		WHERE lpe.id = $1
	`, id)
	if err != nil {
		return false, fmt.Errorf("edge not found: %w", err)
	}
	if planOwner != userID {
		return false, fmt.Errorf("unauthorized access to learning plan edge")
	}

	result, err := r.DB.Exec("DELETE FROM learning_plan_edges WHERE id = $1", id)
	if err != nil {
		return false, fmt.Errorf("failed to delete edge: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	return rowsAffected > 0, nil
}

// CreateNote creates a new note
func (r *mutationResolver) CreateNote(ctx context.Context, input model.CreateNoteInput) (*model.Note, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	noteID := uuid.New()
	now := time.Now()

	// Set defaults
	tags := input.Tags
	if tags == nil {
		tags = []string{}
	}

	// Insert note (search_vector is auto-generated by database)
	query := `
		INSERT INTO notes (
			id, user_id, title, content, tags, linked_type, linked_id,
			created_at, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
	`

	_, err = r.DB.Exec(
		query,
		noteID, userID, input.Title, input.Content, pq.Array(tags),
		input.LinkedType, input.LinkedID, now, now,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create note: %w", err)
	}

	return &model.Note{
		ID:         noteID,
		UserID:     userID,
		Title:      input.Title,
		Content:    input.Content,
		Tags:       tags,
		LinkedType: input.LinkedType,
		LinkedID:   input.LinkedID,
		CreatedAt:  now,
		UpdatedAt:  now,
	}, nil
}

// UpdateNote is the resolver for the updateNote field.
func (r *mutationResolver) UpdateNote(ctx context.Context, id uuid.UUID, input model.UpdateNoteInput) (*model.Note, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	now := time.Now()

	// Build dynamic update query
	updateFields := []string{}
	args := []interface{}{id, userID}
	argIdx := 3

	if input.Title != nil {
		updateFields = append(updateFields, fmt.Sprintf("title = $%d", argIdx))
		args = append(args, *input.Title)
		argIdx++
	}

	if input.Content != nil {
		updateFields = append(updateFields, fmt.Sprintf("content = $%d", argIdx))
		args = append(args, *input.Content)
		argIdx++
	}

	if input.Tags != nil {
		updateFields = append(updateFields, fmt.Sprintf("tags = $%d", argIdx))
		args = append(args, pq.Array(input.Tags))
		argIdx++
	}

	if input.LinkedType != nil {
		updateFields = append(updateFields, fmt.Sprintf("linked_type = $%d", argIdx))
		args = append(args, *input.LinkedType)
		argIdx++
	}

	if input.LinkedID != nil {
		updateFields = append(updateFields, fmt.Sprintf("linked_id = $%d", argIdx))
		args = append(args, *input.LinkedID)
		argIdx++
	}

	if len(updateFields) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	// Add updated_at
	updateFields = append(updateFields, fmt.Sprintf("updated_at = $%d", argIdx))
	args = append(args, now)

	query := fmt.Sprintf(`
		UPDATE notes
		SET %s
		WHERE id = $1 AND user_id = $2
	`, strings.Join(updateFields, ", "))

	result, err := r.DB.Exec(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to update note: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return nil, fmt.Errorf("note not found or unauthorized")
	}

	// Fetch updated note
	var note model.Note
	err = r.DB.Get(&note, `
		SELECT id, user_id, title, content, tags, linked_type, linked_id,
		       created_at, updated_at
		FROM notes
		WHERE id = $1
	`, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated note: %w", err)
	}

	return &note, nil
}

// DeleteNote is the resolver for the deleteNote field.
func (r *mutationResolver) DeleteNote(ctx context.Context, id uuid.UUID) (bool, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return false, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	query := `DELETE FROM notes WHERE id = $1 AND user_id = $2`
	result, err := r.DB.Exec(query, id, userID)
	if err != nil {
		return false, fmt.Errorf("failed to delete note: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return false, fmt.Errorf("note not found or unauthorized")
	}

	return true, nil
}

// CreateReminder is the resolver for the createReminder field.
func (r *mutationResolver) CreateReminder(ctx context.Context, input model.CreateReminderInput) (*model.Reminder, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	reminderID := uuid.New()
	now := time.Now()

	// Set default values
	priority := "medium"
	if input.Priority != nil {
		priority = strings.ToLower(string(*input.Priority))
	}

	repeatPattern := "none"
	if input.RepeatPattern != nil {
		repeatPattern = strings.ToLower(string(*input.RepeatPattern))
	}

	notificationChannels := []string{"browser"}
	if input.NotificationChannels != nil {
		notificationChannels = input.NotificationChannels
	}

	reminderTimes := []int{0}
	if input.ReminderTimes != nil {
		reminderTimes = input.ReminderTimes
	}

	tags := []string{}
	if input.Tags != nil {
		tags = input.Tags
	}

	query := `
		INSERT INTO reminders (
			id, user_id, title, description, due_time, priority,
			repeat_pattern, repeat_rule, repeat_end, event_id,
			notification_channels, reminder_times, tags, created_at, updated_at
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
	`
	_, err = r.DB.Exec(query, reminderID, userID, input.Title, input.Description, input.DueTime,
		priority, repeatPattern, input.RepeatRule, input.RepeatEnd, input.EventID,
		pq.Array(notificationChannels), pq.Array(reminderTimes), pq.Array(tags), now, now)
	if err != nil {
		return nil, fmt.Errorf("failed to create reminder: %w", err)
	}

	// Fetch created reminder
	reminder, err := scanReminder(r.DB.QueryRow(`
		SELECT id, user_id, title, description, due_time, completed, completed_at,
		       priority, repeat_pattern, repeat_rule, repeat_end, event_id,
		       notification_channels, reminder_times, tags, created_at, updated_at
		FROM reminders WHERE id = $1
	`, reminderID))
	if err != nil {
		return nil, fmt.Errorf("failed to fetch reminder: %w", err)
	}

	// Create notification queue entries
	for _, minutes := range reminderTimes {
		scheduledTime := input.DueTime.Add(time.Duration(-minutes) * time.Minute)
		for _, channel := range notificationChannels {
			notifID := uuid.New()
			_, err = r.DB.Exec(`
				INSERT INTO notifications_queue (
					id, user_id, reminder_id, scheduled_time, channel,
					notification_type, message, created_at
				) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
			`, notifID, userID, reminderID, scheduledTime, channel, "reminder",
				fmt.Sprintf("Reminder: %s", input.Title), now)
			if err != nil {
				return nil, fmt.Errorf("failed to create notification: %w", err)
			}
		}
	}

	return reminder, nil
}

// UpdateReminder is the resolver for the updateReminder field.
func (r *mutationResolver) UpdateReminder(ctx context.Context, id uuid.UUID, input model.UpdateReminderInput) (*model.Reminder, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Build dynamic update query
	updates := []string{}
	args := []interface{}{}
	argIdx := 1

	if input.Title != nil {
		updates = append(updates, fmt.Sprintf("title = $%d", argIdx))
		args = append(args, *input.Title)
		argIdx++
	}
	if input.Description != nil {
		updates = append(updates, fmt.Sprintf("description = $%d", argIdx))
		args = append(args, *input.Description)
		argIdx++
	}
	if input.DueTime != nil {
		updates = append(updates, fmt.Sprintf("due_time = $%d", argIdx))
		args = append(args, *input.DueTime)
		argIdx++
	}
	if input.Completed != nil {
		updates = append(updates, fmt.Sprintf("completed = $%d", argIdx))
		args = append(args, *input.Completed)
		argIdx++
		if *input.Completed {
			updates = append(updates, fmt.Sprintf("completed_at = $%d", argIdx))
			args = append(args, time.Now())
			argIdx++
		}
	}
	if input.Priority != nil {
		updates = append(updates, fmt.Sprintf("priority = $%d", argIdx))
		args = append(args, strings.ToLower(string(*input.Priority)))
		argIdx++
	}
	if input.RepeatPattern != nil {
		updates = append(updates, fmt.Sprintf("repeat_pattern = $%d", argIdx))
		args = append(args, strings.ToLower(string(*input.RepeatPattern)))
		argIdx++
	}
	if input.RepeatRule != nil {
		updates = append(updates, fmt.Sprintf("repeat_rule = $%d", argIdx))
		args = append(args, *input.RepeatRule)
		argIdx++
	}
	if input.RepeatEnd != nil {
		updates = append(updates, fmt.Sprintf("repeat_end = $%d", argIdx))
		args = append(args, *input.RepeatEnd)
		argIdx++
	}
	if input.EventID != nil {
		updates = append(updates, fmt.Sprintf("event_id = $%d", argIdx))
		args = append(args, *input.EventID)
		argIdx++
	}
	if input.NotificationChannels != nil {
		updates = append(updates, fmt.Sprintf("notification_channels = $%d", argIdx))
		args = append(args, pq.Array(input.NotificationChannels))
		argIdx++
	}
	if input.ReminderTimes != nil {
		updates = append(updates, fmt.Sprintf("reminder_times = $%d", argIdx))
		args = append(args, pq.Array(input.ReminderTimes))
		argIdx++
	}
	if input.Tags != nil {
		updates = append(updates, fmt.Sprintf("tags = $%d", argIdx))
		args = append(args, pq.Array(input.Tags))
		argIdx++
	}

	if len(updates) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	updates = append(updates, fmt.Sprintf("updated_at = $%d", argIdx))
	args = append(args, time.Now())
	argIdx++

	args = append(args, id, userID)
	query := fmt.Sprintf(`
		UPDATE reminders SET %s
		WHERE id = $%d AND user_id = $%d
	`, strings.Join(updates, ", "), argIdx, argIdx+1)

	result, err := r.DB.Exec(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to update reminder: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return nil, fmt.Errorf("reminder not found or unauthorized")
	}

	// Fetch updated reminder
	reminder, err := scanReminder(r.DB.QueryRow(`
		SELECT id, user_id, title, description, due_time, completed, completed_at,
		       priority, repeat_pattern, repeat_rule, repeat_end, event_id,
		       notification_channels, reminder_times, tags, created_at, updated_at
		FROM reminders WHERE id = $1
	`, id))
	if err != nil {
		return nil, fmt.Errorf("failed to fetch reminder: %w", err)
	}

	return reminder, nil
}

// DeleteReminder is the resolver for the deleteReminder field.
func (r *mutationResolver) DeleteReminder(ctx context.Context, id uuid.UUID) (bool, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return false, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	result, err := r.DB.Exec(`
		DELETE FROM reminders WHERE id = $1 AND user_id = $2
	`, id, userID)
	if err != nil {
		return false, fmt.Errorf("failed to delete reminder: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return false, fmt.Errorf("reminder not found or unauthorized")
	}

	return true, nil
}

// CompleteReminder is the resolver for the completeReminder field.
func (r *mutationResolver) CompleteReminder(ctx context.Context, id uuid.UUID) (*model.Reminder, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	now := time.Now()
	result, err := r.DB.Exec(`
		UPDATE reminders 
		SET completed = true, completed_at = $1, updated_at = $2
		WHERE id = $3 AND user_id = $4
	`, now, now, id, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to complete reminder: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return nil, fmt.Errorf("reminder not found or unauthorized")
	}

	// Fetch updated reminder
	reminder, err := scanReminder(r.DB.QueryRow(`
		SELECT id, user_id, title, description, due_time, completed, completed_at,
		       priority, repeat_pattern, repeat_rule, repeat_end, event_id,
		       notification_channels, reminder_times, tags, created_at, updated_at
		FROM reminders WHERE id = $1
	`, id))
	if err != nil {
		return nil, fmt.Errorf("failed to fetch reminder: %w", err)
	}

	return reminder, nil
}

// SnoozeReminder is the resolver for the snoozeReminder field.
func (r *mutationResolver) SnoozeReminder(ctx context.Context, id uuid.UUID, minutes int) (*model.Reminder, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Get current reminder
	reminder, err := scanReminder(r.DB.QueryRow(`
		SELECT id, user_id, title, description, due_time, completed, completed_at,
		       priority, repeat_pattern, repeat_rule, repeat_end, event_id,
		       notification_channels, reminder_times, tags, created_at, updated_at
		FROM reminders WHERE id = $1 AND user_id = $2
	`, id, userID))
	if err != nil {
		return nil, fmt.Errorf("reminder not found: %w", err)
	}

	// Add minutes to due_time
	newDueTime := reminder.DueTime.Add(time.Duration(minutes) * time.Minute)
	now := time.Now()

	result, err := r.DB.Exec(`
		UPDATE reminders 
		SET due_time = $1, updated_at = $2
		WHERE id = $3 AND user_id = $4
	`, newDueTime, now, id, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to snooze reminder: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return nil, fmt.Errorf("reminder not found or unauthorized")
	}

	// Update notification queue times
	_, err = r.DB.Exec(`
		UPDATE notifications_queue
		SET scheduled_time = scheduled_time + ($1 || ' minutes')::interval
		WHERE reminder_id = $2 AND sent = false
	`, minutes, id)
	if err != nil {
		return nil, fmt.Errorf("failed to update notifications: %w", err)
	}

	// Fetch updated reminder
	reminder.DueTime = newDueTime
	reminder.UpdatedAt = now

	return reminder, nil
}

// MarkNotificationSent is the resolver for the markNotificationSent field.
func (r *mutationResolver) MarkNotificationSent(ctx context.Context, id uuid.UUID) (*model.Notification, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	now := time.Now()
	result, err := r.DB.Exec(`
		UPDATE notifications_queue
		SET sent = true, sent_at = $1
		WHERE id = $2 AND user_id = $3
	`, now, id, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to mark notification as sent: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return nil, fmt.Errorf("notification not found or unauthorized")
	}

	// Fetch updated notification
	var notification model.Notification
	err = r.DB.Get(&notification, `
		SELECT id, user_id, event_id, reminder_id, scheduled_time, sent, sent_at,
		       channel, notification_type, message, created_at
		FROM notifications_queue WHERE id = $1
	`, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch notification: %w", err)
	}

	return &notification, nil
}

// DismissNotification is the resolver for the dismissNotification field.
func (r *mutationResolver) DismissNotification(ctx context.Context, id uuid.UUID) (bool, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return false, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	result, err := r.DB.Exec(`
		DELETE FROM notifications_queue WHERE id = $1 AND user_id = $2
	`, id, userID)
	if err != nil {
		return false, fmt.Errorf("failed to dismiss notification: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return false, fmt.Errorf("notification not found or unauthorized")
	}

	return true, nil
}

// CreateFile creates a new file record
// Me returns the authenticated user
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// Service accounts can query their own user info
	userUUID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// TODO: Fetch full user details from database including is_service and is_active
	return &model.User{
		ID:        userUUID,
		Email:     user.Email,
		Name:      user.Name,
		IsService: user.IsService,
		IsActive:  true, // TODO: fetch from database
	}, nil
}

// Skills returns all skills for the authenticated user
func (r *queryResolver) Skills(ctx context.Context) ([]*model.Skill, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	var skills []*model.Skill
	err = r.DB.Select(&skills, `
		SELECT 
			id,
			user_id,
			name,
			level,
			notes,
			created_at,
			updated_at
		FROM skills 
		WHERE user_id = $1
		ORDER BY name ASC
	`, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch skills: %w", err)
	}

	return skills, nil
}

// Skill returns a single skill by ID
func (r *queryResolver) Skill(ctx context.Context, id uuid.UUID) (*model.Skill, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	var skill model.Skill
	err = r.DB.Get(&skill, `
		SELECT 
			id,
			user_id,
			name,
			level,
			notes,
			created_at,
			updated_at
		FROM skills WHERE id = $1 AND user_id = $2
	`, id, userID)
	if err != nil {
		return nil, fmt.Errorf("skill not found: %w", err)
	}

	return &skill, nil
}

// Activities returns paginated activities with optional filters
func (r *queryResolver) Activities(ctx context.Context, filter *model.ActivityFilter, limit *int, offset *int) (*model.ActivityConnection, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Build query with filters
	query := `
		SELECT 
			id,
			user_id,
			skill_id,
			name,
			duration,
			date,
			notes,
			status,
			started_at,
			paused_at,
			paused_duration,
			created_at
		FROM activities 
		WHERE user_id = $1
	`
	args := []interface{}{userID}
	paramCount := 1

	if filter != nil {
		if filter.SkillID != nil {
			paramCount++
			query += fmt.Sprintf(" AND skill_id = $%d", paramCount)
			args = append(args, *filter.SkillID)
		}
		if filter.StartDate != nil {
			paramCount++
			query += fmt.Sprintf(" AND date >= $%d", paramCount)
			args = append(args, *filter.StartDate)
		}
		if filter.EndDate != nil {
			paramCount++
			query += fmt.Sprintf(" AND date <= $%d", paramCount)
			args = append(args, *filter.EndDate)
		}
		if filter.Status != nil {
			paramCount++
			query += fmt.Sprintf(" AND status = $%d", paramCount)
			args = append(args, *filter.Status)
		}
	}

	query += " ORDER BY date DESC, created_at DESC"

	// Apply pagination
	if limit != nil {
		paramCount++
		query += fmt.Sprintf(" LIMIT $%d", paramCount)
		args = append(args, *limit)
	}
	if offset != nil {
		paramCount++
		query += fmt.Sprintf(" OFFSET $%d", paramCount)
		args = append(args, *offset)
	}

	var activities []*model.Activity
	err = r.DB.Select(&activities, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch activities: %w", err)
	}

	// Get total count
	countQuery := `SELECT COUNT(*) FROM activities WHERE user_id = $1`
	countArgs := []interface{}{userID}
	if filter != nil {
		paramIdx := 1
		if filter.SkillID != nil {
			paramIdx++
			countQuery += fmt.Sprintf(" AND skill_id = $%d", paramIdx)
			countArgs = append(countArgs, *filter.SkillID)
		}
		if filter.StartDate != nil {
			paramIdx++
			countQuery += fmt.Sprintf(" AND date >= $%d", paramIdx)
			countArgs = append(countArgs, *filter.StartDate)
		}
		if filter.EndDate != nil {
			paramIdx++
			countQuery += fmt.Sprintf(" AND date <= $%d", paramIdx)
			countArgs = append(countArgs, *filter.EndDate)
		}
		if filter.Status != nil {
			paramIdx++
			countQuery += fmt.Sprintf(" AND status = $%d", paramIdx)
			countArgs = append(countArgs, *filter.Status)
		}
	}

	var totalCount int
	err = r.DB.Get(&totalCount, countQuery, countArgs...)
	if err != nil {
		return nil, fmt.Errorf("failed to count activities: %w", err)
	}

	// Determine if there are more results
	hasMore := false
	if limit != nil && offset != nil {
		hasMore = (*offset + *limit) < totalCount
	}

	return &model.ActivityConnection{
		Nodes:      activities,
		TotalCount: totalCount,
		HasMore:    hasMore,
	}, nil
}

// Activity returns a single activity by ID
func (r *queryResolver) Activity(ctx context.Context, id uuid.UUID) (*model.Activity, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// TODO: Implement database query with authorization check
	_ = user
	_ = id
	return nil, fmt.Errorf("not implemented")
}

// ActiveSession returns the user's current active session
func (r *queryResolver) ActiveSession(ctx context.Context) (*model.Activity, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Query for active session
	var activity model.Activity
	err = r.DB.Get(&activity, `
		SELECT 
			id,
			user_id,
			skill_id,
			name,
			duration,
			date,
			notes,
			status,
			started_at,
			paused_at,
			paused_duration,
			created_at
		FROM activities
		WHERE user_id = $1 AND status IN ('ACTIVE', 'PAUSED')
		ORDER BY started_at DESC
		LIMIT 1
	`, userID)

	if err != nil {
		// No active session found - this is not an error, just return nil
		return nil, nil
	}

	// Fetch associated skill
	var skill model.Skill
	err = r.DB.Get(&skill, `
		SELECT 
			id,
			user_id,
			name,
			level,
			notes,
			created_at,
			updated_at
		FROM skills WHERE id = $1
	`, activity.SkillID)
	if err != nil {
		// If skill not found, continue without it
		return &activity, nil
	}

	activity.Skill = &skill

	return &activity, nil
}

// Events returns events within a date range
func (r *queryResolver) Events(ctx context.Context, startDate time.Time, endDate time.Time, typeArg *model.EventType) ([]*model.Event, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Adjust endDate to end of day (23:59:59.999999) to include all events on that day
	endOfDay := time.Date(endDate.Year(), endDate.Month(), endDate.Day(), 23, 59, 59, 999999999, endDate.Location())

	query := `
		SELECT 
			id,
			user_id,
			title,
			description,
			type,
			start_time,
			end_time,
			all_day,
			recurrence,
			recurrence_rule,
			recurrence_end,
			skill_id,
			activity_id,
			learning_plan_id,
			color,
			location,
			COALESCE(attendees, '{}') as attendees,
			COALESCE(tags, '{}') as tags,
			created_at,
			updated_at
		FROM events
		WHERE user_id = $1 AND start_time >= $2 AND start_time <= $3
	`
	args := []interface{}{userID, startDate, endOfDay}

	if typeArg != nil {
		typeStr := strings.ToLower(string(*typeArg))
		query += " AND type = $4"
		args = append(args, typeStr)
	}

	query += " ORDER BY start_time ASC"

	rows, err := r.DB.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query events: %w", err)
	}
	defer rows.Close()

	var events []*model.Event
	for rows.Next() {
		var event model.Event
		var attendees []string
		var tags []string
		var eventType string
		var recurrence string

		err := rows.Scan(
			&event.ID,
			&event.UserID,
			&event.Title,
			&event.Description,
			&eventType,
			&event.StartTime,
			&event.EndTime,
			&event.AllDay,
			&recurrence,
			&event.RecurrenceRule,
			&event.RecurrenceEnd,
			&event.SkillID,
			&event.ActivityID,
			&event.LearningPlanID,
			&event.Color,
			&event.Location,
			pq.Array(&attendees),
			pq.Array(&tags),
			&event.CreatedAt,
			&event.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan event: %w", err)
		}

		// Convert lowercase database values to uppercase enum types
		event.Type = model.EventType(strings.ToUpper(eventType))
		event.Recurrence = model.Recurrence(strings.ToUpper(recurrence))
		event.Attendees = attendees
		event.Tags = tags
		events = append(events, &event)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating events: %w", err)
	}

	return events, nil
}

// Event returns a single event by ID
func (r *queryResolver) Event(ctx context.Context, id uuid.UUID) (*model.Event, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	var event model.Event
	var eventType string
	var recurrence string
	var attendees []string
	var tags []string

	err = r.DB.QueryRow(`
		SELECT id, user_id, title, description, type, start_time, end_time,
		       all_day, recurrence, recurrence_rule, recurrence_end,
		       skill_id, activity_id, learning_plan_id, color, location,
		       COALESCE(attendees, '{}'), COALESCE(tags, '{}'), created_at, updated_at
		FROM events
		WHERE id = $1 AND user_id = $2
	`, id, userID).Scan(
		&event.ID,
		&event.UserID,
		&event.Title,
		&event.Description,
		&eventType,
		&event.StartTime,
		&event.EndTime,
		&event.AllDay,
		&recurrence,
		&event.RecurrenceRule,
		&event.RecurrenceEnd,
		&event.SkillID,
		&event.ActivityID,
		&event.LearningPlanID,
		&event.Color,
		&event.Location,
		pq.Array(&attendees),
		pq.Array(&tags),
		&event.CreatedAt,
		&event.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("event not found: %w", err)
	}

	// Convert lowercase database values to uppercase enum types
	event.Type = model.EventType(strings.ToUpper(eventType))
	event.Recurrence = model.Recurrence(strings.ToUpper(recurrence))
	event.Attendees = attendees
	event.Tags = tags

	return &event, nil
}

// UpcomingEvents returns upcoming events
func (r *queryResolver) UpcomingEvents(ctx context.Context, limit *int) ([]*model.Event, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	// TODO: Query events with start_time >= NOW(), order by start_time
	_ = user
	_ = limit
	return []*model.Event{}, nil
}

// LearningPlans returns all learning plans for the user
func (r *queryResolver) LearningPlans(ctx context.Context) ([]*model.LearningPlan, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	var plans []*model.LearningPlan

	type dbLearningPlan struct {
		ID                 uuid.UUID      `db:"id"`
		UserID             uuid.UUID      `db:"user_id"`
		Name               string         `db:"name"`
		Description        *string        `db:"description"`
		SkillIDs           pq.StringArray `db:"skill_ids"`
		ScheduleJSON       []byte         `db:"schedule"`
		TargetHoursPerWeek *float64       `db:"target_hours_per_week"`
		StartDate          time.Time      `db:"start_date"`
		EndDate            *time.Time     `db:"end_date"`
		CompletedHours     float64        `db:"completed_hours"`
		CreatedAt          time.Time      `db:"created_at"`
		UpdatedAt          time.Time      `db:"updated_at"`
	}

	var dbPlans []dbLearningPlan
	err = r.DB.Select(&dbPlans, `
		SELECT id, user_id, name, description, skill_ids, schedule,
		       target_hours_per_week, start_date, end_date, completed_hours,
		       created_at, updated_at
		FROM learning_plans
		WHERE user_id = $1
		ORDER BY created_at DESC
	`, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch learning plans: %w", err)
	}

	// Convert database plans to model plans
	for _, dbPlan := range dbPlans {
		// Convert skill IDs from string array to UUID array
		skillIDs := make([]uuid.UUID, len(dbPlan.SkillIDs))
		for i, idStr := range dbPlan.SkillIDs {
			skillIDs[i], _ = uuid.Parse(idStr)
		}

		// Unmarshal schedule
		var schedule model.Schedule
		err = json.Unmarshal(dbPlan.ScheduleJSON, &schedule)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal schedule: %w", err)
		}

		plan := &model.LearningPlan{
			ID:                 dbPlan.ID,
			UserID:             dbPlan.UserID,
			Name:               dbPlan.Name,
			Description:        dbPlan.Description,
			SkillIds:           skillIDs,
			Skills:             []*model.Skill{}, // Resolved by field resolver
			Schedule:           &schedule,
			TargetHoursPerWeek: dbPlan.TargetHoursPerWeek,
			StartDate:          dbPlan.StartDate,
			EndDate:            dbPlan.EndDate,
			CompletedHours:     dbPlan.CompletedHours,
			Nodes:              []*model.LearningPlanNode{}, // Resolved by field resolver
			Edges:              []*model.LearningPlanEdge{}, // Resolved by field resolver
			CreatedAt:          dbPlan.CreatedAt,
			UpdatedAt:          dbPlan.UpdatedAt,
		}
		plans = append(plans, plan)
	}

	return plans, nil
}

// LearningPlan returns a single learning plan by ID
func (r *queryResolver) LearningPlan(ctx context.Context, id uuid.UUID) (*model.LearningPlan, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	type dbLearningPlan struct {
		ID                 uuid.UUID      `db:"id"`
		UserID             uuid.UUID      `db:"user_id"`
		Name               string         `db:"name"`
		Description        *string        `db:"description"`
		SkillIDs           pq.StringArray `db:"skill_ids"`
		ScheduleJSON       []byte         `db:"schedule"`
		TargetHoursPerWeek *float64       `db:"target_hours_per_week"`
		StartDate          time.Time      `db:"start_date"`
		EndDate            *time.Time     `db:"end_date"`
		CompletedHours     float64        `db:"completed_hours"`
		CreatedAt          time.Time      `db:"created_at"`
		UpdatedAt          time.Time      `db:"updated_at"`
	}

	var dbPlan dbLearningPlan
	err = r.DB.Get(&dbPlan, `
		SELECT id, user_id, name, description, skill_ids, schedule,
		       target_hours_per_week, start_date, end_date, completed_hours,
		       created_at, updated_at
		FROM learning_plans
		WHERE id = $1 AND user_id = $2
	`, id, userID)
	if err != nil {
		return nil, fmt.Errorf("learning plan not found: %w", err)
	}

	// Convert skill IDs from string array to UUID array
	skillIDs := make([]uuid.UUID, len(dbPlan.SkillIDs))
	for i, idStr := range dbPlan.SkillIDs {
		skillIDs[i], _ = uuid.Parse(idStr)
	}

	// Unmarshal schedule
	var schedule model.Schedule
	err = json.Unmarshal(dbPlan.ScheduleJSON, &schedule)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal schedule: %w", err)
	}

	plan := &model.LearningPlan{
		ID:                 dbPlan.ID,
		UserID:             dbPlan.UserID,
		Name:               dbPlan.Name,
		Description:        dbPlan.Description,
		SkillIds:           skillIDs,
		Skills:             []*model.Skill{}, // Resolved by field resolver
		Schedule:           &schedule,
		TargetHoursPerWeek: dbPlan.TargetHoursPerWeek,
		StartDate:          dbPlan.StartDate,
		EndDate:            dbPlan.EndDate,
		CompletedHours:     dbPlan.CompletedHours,
		Nodes:              []*model.LearningPlanNode{}, // Resolved by field resolver
		Edges:              []*model.LearningPlanEdge{}, // Resolved by field resolver
		CreatedAt:          dbPlan.CreatedAt,
		UpdatedAt:          dbPlan.UpdatedAt,
	}

	return plan, nil
}

// Notes returns paginated notes with optional filters
func (r *queryResolver) Notes(ctx context.Context, filter *model.NoteFilter, limit *int, offset *int) (*model.NoteConnection, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Set defaults for pagination
	limitVal := 10
	if limit != nil && *limit > 0 {
		limitVal = *limit
	}
	offsetVal := 0
	if offset != nil && *offset > 0 {
		offsetVal = *offset
	}

	// Build query with filters
	queryStr := `
		SELECT 
			id,
			user_id,
			title,
			content,
			COALESCE(tags, '{}') as tags,
			linked_type,
			linked_id,
			created_at,
			updated_at
		FROM notes
		WHERE user_id = $1
	`
	args := []interface{}{userID}
	paramIdx := 1

	if filter != nil {
		if len(filter.Tags) > 0 {
			paramIdx++
			queryStr += fmt.Sprintf(" AND tags && $%d", paramIdx)
			args = append(args, pq.Array(filter.Tags))
		}
		if filter.LinkedType != nil {
			paramIdx++
			queryStr += fmt.Sprintf(" AND linked_type = $%d", paramIdx)
			args = append(args, *filter.LinkedType)
		}
		if filter.LinkedID != nil {
			paramIdx++
			queryStr += fmt.Sprintf(" AND linked_id = $%d", paramIdx)
			args = append(args, *filter.LinkedID)
		}
	}

	queryStr += " ORDER BY created_at DESC"
	paramIdx++
	queryStr += fmt.Sprintf(" LIMIT $%d", paramIdx)
	args = append(args, limitVal)
	paramIdx++
	queryStr += fmt.Sprintf(" OFFSET $%d", paramIdx)
	args = append(args, offsetVal)

	// Query notes with manual row scanning for array handling
	rows, err := r.DB.Query(queryStr, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query notes: %w", err)
	}
	defer rows.Close()

	var notes []*model.Note
	for rows.Next() {
		var note model.Note
		var tags []string

		err := rows.Scan(
			&note.ID,
			&note.UserID,
			&note.Title,
			&note.Content,
			pq.Array(&tags),
			&note.LinkedType,
			&note.LinkedID,
			&note.CreatedAt,
			&note.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan note: %w", err)
		}

		note.Tags = tags
		notes = append(notes, &note)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating notes: %w", err)
	}

	// Get total count
	countQuery := "SELECT COUNT(*) FROM notes WHERE user_id = $1"
	countArgs := []interface{}{userID}
	if filter != nil {
		paramIdx := 1
		if len(filter.Tags) > 0 {
			paramIdx++
			countQuery += fmt.Sprintf(" AND tags && $%d", paramIdx)
			countArgs = append(countArgs, pq.Array(filter.Tags))
		}
		if filter.LinkedType != nil {
			paramIdx++
			countQuery += fmt.Sprintf(" AND linked_type = $%d", paramIdx)
			countArgs = append(countArgs, *filter.LinkedType)
		}
		if filter.LinkedID != nil {
			paramIdx++
			countQuery += fmt.Sprintf(" AND linked_id = $%d", paramIdx)
			countArgs = append(countArgs, *filter.LinkedID)
		}
	}

	var totalCount int
	err = r.DB.Get(&totalCount, countQuery, countArgs...)
	if err != nil {
		return nil, fmt.Errorf("failed to count notes: %w", err)
	}

	// Determine if there are more results
	hasMore := (offsetVal + limitVal) < totalCount

	return &model.NoteConnection{
		Nodes:      notes,
		TotalCount: totalCount,
		HasMore:    hasMore,
	}, nil
}

// Note returns a single note by ID
func (r *queryResolver) Note(ctx context.Context, id uuid.UUID) (*model.Note, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	var note model.Note
	var tags []string

	err = r.DB.QueryRow(`
		SELECT 
			id,
			user_id,
			title,
			content,
			COALESCE(tags, '{}') as tags,
			linked_type,
			linked_id,
			created_at,
			updated_at
		FROM notes
		WHERE id = $1 AND user_id = $2
	`, id, userID).Scan(
		&note.ID,
		&note.UserID,
		&note.Title,
		&note.Content,
		pq.Array(&tags),
		&note.LinkedType,
		&note.LinkedID,
		&note.CreatedAt,
		&note.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("note not found: %w", err)
	}

	note.Tags = tags
	return &note, nil
}

// SearchNotes performs full-text search on notes
func (r *queryResolver) SearchNotes(ctx context.Context, query string) ([]*model.Note, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	if query == "" {
		return []*model.Note{}, nil
	}

	// Use PostgreSQL full-text search with the search_vector column
	// Convert the query to tsquery format (handle multiple words)
	rows, err := r.DB.Query(`
		SELECT 
			id,
			user_id,
			title,
			content,
			COALESCE(tags, '{}') as tags,
			linked_type,
			linked_id,
			created_at,
			updated_at,
			ts_rank(search_vector, to_tsquery('english', $2)) AS rank
		FROM notes
		WHERE user_id = $1 
		  AND search_vector @@ to_tsquery('english', $2)
		ORDER BY rank DESC, created_at DESC
		LIMIT 50
	`, userID, strings.ReplaceAll(query, " ", " & "))
	if err != nil {
		return nil, fmt.Errorf("failed to search notes: %w", err)
	}
	defer rows.Close()

	var notes []*model.Note
	for rows.Next() {
		var note model.Note
		var tags []string
		var rank float64

		err := rows.Scan(
			&note.ID,
			&note.UserID,
			&note.Title,
			&note.Content,
			pq.Array(&tags),
			&note.LinkedType,
			&note.LinkedID,
			&note.CreatedAt,
			&note.UpdatedAt,
			&rank,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan note: %w", err)
		}

		note.Tags = tags
		notes = append(notes, &note)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating notes: %w", err)
	}

	return notes, nil
}

// Reminders is the resolver for the reminders field.
func (r *queryResolver) Reminders(ctx context.Context, filter *model.ReminderFilter, limit *int, offset *int) (*model.ReminderConnection, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Build query with filters
	queryBuilder := strings.Builder{}
	queryBuilder.WriteString(`
		SELECT id, user_id, title, description, due_time, completed, completed_at,
		       priority, repeat_pattern, repeat_rule, repeat_end, event_id,
		       notification_channels, reminder_times, tags, created_at, updated_at
		FROM reminders
		WHERE user_id = $1
	`)

	args := []interface{}{userID}
	argIdx := 2

	if filter != nil {
		if filter.Completed != nil {
			queryBuilder.WriteString(fmt.Sprintf(" AND completed = $%d", argIdx))
			args = append(args, *filter.Completed)
			argIdx++
		}
		if filter.Priority != nil {
			queryBuilder.WriteString(fmt.Sprintf(" AND priority = $%d", argIdx))
			args = append(args, string(*filter.Priority))
			argIdx++
		}
		if filter.EventID != nil {
			queryBuilder.WriteString(fmt.Sprintf(" AND event_id = $%d", argIdx))
			args = append(args, *filter.EventID)
			argIdx++
		}
		if filter.StartDate != nil {
			queryBuilder.WriteString(fmt.Sprintf(" AND due_time >= $%d", argIdx))
			args = append(args, *filter.StartDate)
			argIdx++
		}
		if filter.EndDate != nil {
			queryBuilder.WriteString(fmt.Sprintf(" AND due_time <= $%d", argIdx))
			args = append(args, *filter.EndDate)
			argIdx++
		}
		if len(filter.Tags) > 0 {
			queryBuilder.WriteString(fmt.Sprintf(" AND tags && $%d", argIdx))
			args = append(args, pq.Array(filter.Tags))
			argIdx++
		}
	}

	queryBuilder.WriteString(" ORDER BY due_time ASC")

	// Apply limit and offset
	limitVal := 50
	if limit != nil && *limit > 0 {
		limitVal = *limit
	}
	offsetVal := 0
	if offset != nil && *offset > 0 {
		offsetVal = *offset
	}

	queryBuilder.WriteString(fmt.Sprintf(" LIMIT $%d OFFSET $%d", argIdx, argIdx+1))
	args = append(args, limitVal, offsetVal)

	// Execute query
	rows, err := r.DB.Queryx(queryBuilder.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query reminders: %w", err)
	}
	defer rows.Close()

	reminders := []*model.Reminder{}
	for rows.Next() {
		reminder, err := scanReminder(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan reminder: %w", err)
		}
		reminders = append(reminders, reminder)
	}

	// Get total count
	var totalCount int
	countQuery := `SELECT COUNT(*) FROM reminders WHERE user_id = $1`
	err = r.DB.Get(&totalCount, countQuery, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get total count: %w", err)
	}

	hasMore := offsetVal+len(reminders) < totalCount

	return &model.ReminderConnection{
		Nodes:      reminders,
		TotalCount: totalCount,
		HasMore:    hasMore,
	}, nil
}

// Reminder is the resolver for the reminder field.
func (r *queryResolver) Reminder(ctx context.Context, id uuid.UUID) (*model.Reminder, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	reminder, err := scanReminder(r.DB.QueryRow(`
		SELECT id, user_id, title, description, due_time, completed, completed_at,
		       priority, repeat_pattern, repeat_rule, repeat_end, event_id,
		       notification_channels, reminder_times, tags, created_at, updated_at
		FROM reminders
		WHERE id = $1 AND user_id = $2
	`, id, userID))
	if err != nil {
		return nil, fmt.Errorf("reminder not found: %w", err)
	}

	return reminder, nil
}

// UpcomingReminders is the resolver for the upcomingReminders field.
func (r *queryResolver) UpcomingReminders(ctx context.Context, limit *int) ([]*model.Reminder, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	limitVal := 10
	if limit != nil && *limit > 0 {
		limitVal = *limit
	}

	rows, err := r.DB.Queryx(`
		SELECT id, user_id, title, description, due_time, completed, completed_at,
		       priority, repeat_pattern, repeat_rule, repeat_end, event_id,
		       notification_channels, reminder_times, tags, created_at, updated_at
		FROM reminders
		WHERE user_id = $1 AND completed = false AND due_time > NOW()
		ORDER BY due_time ASC
		LIMIT $2
	`, userID, limitVal)
	if err != nil {
		return nil, fmt.Errorf("failed to query upcoming reminders: %w", err)
	}
	defer rows.Close()

	reminders := []*model.Reminder{}
	for rows.Next() {
		reminder, err := scanReminder(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan reminder: %w", err)
		}
		reminders = append(reminders, reminder)
	}

	return reminders, nil
}

// OverdueReminders is the resolver for the overdueReminders field.
func (r *queryResolver) OverdueReminders(ctx context.Context) ([]*model.Reminder, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	rows, err := r.DB.Queryx(`
		SELECT id, user_id, title, description, due_time, completed, completed_at,
		       priority, repeat_pattern, repeat_rule, repeat_end, event_id,
		       notification_channels, reminder_times, tags, created_at, updated_at
		FROM reminders
		WHERE user_id = $1 AND completed = false AND due_time < NOW()
		ORDER BY due_time DESC
	`, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to query overdue reminders: %w", err)
	}
	defer rows.Close()

	reminders := []*model.Reminder{}
	for rows.Next() {
		reminder, err := scanReminder(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan reminder: %w", err)
		}
		reminders = append(reminders, reminder)
	}

	return reminders, nil
}

// Notifications is the resolver for the notifications field.
func (r *queryResolver) Notifications(ctx context.Context, sent *bool, limit *int, offset *int) (*model.NotificationConnection, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	queryBuilder := strings.Builder{}
	queryBuilder.WriteString(`
		SELECT id, user_id, event_id, reminder_id, scheduled_time, sent, sent_at,
		       channel, notification_type, message, created_at
		FROM notifications_queue
		WHERE user_id = $1
	`)

	args := []interface{}{userID}
	argIdx := 2

	if sent != nil {
		queryBuilder.WriteString(fmt.Sprintf(" AND sent = $%d", argIdx))
		args = append(args, *sent)
		argIdx++
	}

	queryBuilder.WriteString(" ORDER BY scheduled_time DESC")

	limitVal := 50
	if limit != nil && *limit > 0 {
		limitVal = *limit
	}
	offsetVal := 0
	if offset != nil && *offset > 0 {
		offsetVal = *offset
	}

	queryBuilder.WriteString(fmt.Sprintf(" LIMIT $%d OFFSET $%d", argIdx, argIdx+1))
	args = append(args, limitVal, offsetVal)

	rows, err := r.DB.Queryx(queryBuilder.String(), args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query notifications: %w", err)
	}
	defer rows.Close()

	notifications := []*model.Notification{}
	for rows.Next() {
		var notification model.Notification
		err := rows.StructScan(&notification)
		if err != nil {
			return nil, fmt.Errorf("failed to scan notification: %w", err)
		}
		notifications = append(notifications, &notification)
	}

	var totalCount int
	err = r.DB.Get(&totalCount, `SELECT COUNT(*) FROM notifications_queue WHERE user_id = $1`, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get total count: %w", err)
	}

	hasMore := offsetVal+len(notifications) < totalCount

	return &model.NotificationConnection{
		Nodes:      notifications,
		TotalCount: totalCount,
		HasMore:    hasMore,
	}, nil
}

// PendingNotifications is the resolver for the pendingNotifications field.
func (r *queryResolver) PendingNotifications(ctx context.Context) ([]*model.Notification, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	rows, err := r.DB.Queryx(`
		SELECT id, user_id, event_id, reminder_id, scheduled_time, sent, sent_at,
		       channel, notification_type, message, created_at
		FROM notifications_queue
		WHERE user_id = $1 AND sent = false AND scheduled_time <= NOW()
		ORDER BY scheduled_time ASC
	`, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to query pending notifications: %w", err)
	}
	defer rows.Close()

	notifications := []*model.Notification{}
	for rows.Next() {
		var notification model.Notification
		err := rows.StructScan(&notification)
		if err != nil {
			return nil, fmt.Errorf("failed to scan notification: %w", err)
		}
		notifications = append(notifications, &notification)
	}

	return notifications, nil
}

// ActivityStats is the resolver for the activityStats field.
func (r *queryResolver) ActivityStats(ctx context.Context, startDate time.Time, endDate time.Time) (*model.ActivityStats, error) {
	user, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, err
	}

	userID, err := uuid.Parse(user.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID: %w", err)
	}

	// Query activities for the date range
	query := `
		SELECT a.id, a.skill_id, s.name as skill_name, a.duration
		FROM activities a
		JOIN skills s ON a.skill_id = s.id
		WHERE a.user_id = $1 
		  AND a.date >= $2 
		  AND a.date <= $3
		  AND a.status = 'COMPLETED'
		ORDER BY s.name
	`

	rows, err := r.DB.Query(query, userID, startDate, endDate)
	if err != nil {
		return nil, fmt.Errorf("failed to query activities: %w", err)
	}
	defer rows.Close()

	// Aggregate statistics
	totalActivities := 0
	totalMinutes := 0
	skillMap := make(map[uuid.UUID]*model.SkillStats)

	for rows.Next() {
		var activityID, skillID uuid.UUID
		var skillName string
		var duration int

		if err := rows.Scan(&activityID, &skillID, &skillName, &duration); err != nil {
			return nil, fmt.Errorf("failed to scan activity: %w", err)
		}

		totalActivities++
		totalMinutes += duration

		// Update skill breakdown
		if stats, exists := skillMap[skillID]; exists {
			stats.ActivityCount++
			stats.TotalMinutes += duration
			stats.TotalHours = float64(stats.TotalMinutes) / 60.0
		} else {
			skillMap[skillID] = &model.SkillStats{
				SkillID:       skillID,
				SkillName:     skillName,
				ActivityCount: 1,
				TotalMinutes:  duration,
				TotalHours:    float64(duration) / 60.0,
			}
		}
	}

	// Convert skill map to slice
	skillBreakdown := make([]*model.SkillStats, 0, len(skillMap))
	for _, stats := range skillMap {
		skillBreakdown = append(skillBreakdown, stats)
	}

	// Determine period string
	period := "custom"
	if startDate.Equal(endDate) {
		period = "today"
	} else if endDate.Sub(startDate).Hours() <= 24*7 {
		period = "week"
	} else if endDate.Sub(startDate).Hours() <= 24*31 {
		period = "month"
	}

	return &model.ActivityStats{
		TotalActivities: totalActivities,
		TotalMinutes:    totalMinutes,
		TotalHours:      float64(totalMinutes) / 60.0,
		SkillBreakdown:  skillBreakdown,
		Period:          period,
	}, nil
}

// Files returns a paginated list of files for the current user

// EventReminder is the resolver for the eventReminder field.
func (r *subscriptionResolver) EventReminder(ctx context.Context, userID uuid.UUID) (<-chan *model.EventNotification, error) {
	panic(fmt.Errorf("not implemented: EventReminder - eventReminder"))
}

// ReminderNotification is the resolver for the reminderNotification field.
func (r *subscriptionResolver) ReminderNotification(ctx context.Context, userID uuid.UUID) (<-chan *model.ReminderNotification, error) {
	panic(fmt.Errorf("not implemented: ReminderNotification - reminderNotification"))
}

// LearningPlan returns LearningPlanResolver implementation.
func (r *Resolver) LearningPlan() LearningPlanResolver { return &learningPlanResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type learningPlanResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) CreateFile(ctx context.Context, input model.CreateFileInput) (*model.File, error) {
	currentUser := auth.UserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	query := `INSERT INTO files
	          (user_id, filename, directory, original_filename, mime_type, file_size,
	           telegram_file_id, telegram_file_unique_id, telegram_message_id, storage_path, tags, description)
	          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
	          RETURNING id, user_id, filename, directory, original_filename, mime_type,
	          file_size, telegram_file_id, telegram_file_unique_id, telegram_message_id,
	          storage_path, tags, description, created_at, updated_at`

	tags := []string{}
	if input.Tags != nil {
		tags = input.Tags
	}

	file, err := scanFile(r.DB.QueryRowContext(ctx, query,
		currentUser.ID,
		input.Filename,
		input.Directory,
		input.OriginalFilename,
		input.MimeType,
		input.FileSize,
		input.TelegramFileID,
		input.TelegramFileUniqueID,
		input.TelegramMessageID,
		input.StoragePath,
		pq.Array(tags),
		input.Description,
	))

	if err != nil {
		return nil, fmt.Errorf("failed to create file: %w", err)
	}

	return file, nil
}
func (r *mutationResolver) UpdateFile(ctx context.Context, id uuid.UUID, input model.UpdateFileInput) (*model.File, error) {
	currentUser := auth.UserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Build dynamic update query
	updates := []string{}
	args := []interface{}{id, currentUser.ID}
	argCount := 2

	if input.Filename != nil {
		argCount++
		updates = append(updates, fmt.Sprintf("filename = $%d", argCount))
		args = append(args, *input.Filename)
	}
	if input.Directory != nil {
		argCount++
		updates = append(updates, fmt.Sprintf("directory = $%d", argCount))
		args = append(args, *input.Directory)
	}
	if input.Tags != nil {
		argCount++
		updates = append(updates, fmt.Sprintf("tags = $%d", argCount))
		args = append(args, pq.Array(input.Tags))
	}
	if input.Description != nil {
		argCount++
		updates = append(updates, fmt.Sprintf("description = $%d", argCount))
		args = append(args, *input.Description)
	}
	if input.TelegramFileID != nil {
		argCount++
		updates = append(updates, fmt.Sprintf("telegram_file_id = $%d", argCount))
		args = append(args, *input.TelegramFileID)
	}

	if len(updates) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	updates = append(updates, "updated_at = NOW()")

	query := fmt.Sprintf(`UPDATE files SET %s WHERE id = $1 AND user_id = $2
	                      RETURNING id, user_id, filename, directory, original_filename, mime_type,
	                      file_size, telegram_file_id, telegram_file_unique_id, telegram_message_id,
	                      storage_path, tags, description, created_at, updated_at`,
		strings.Join(updates, ", "))

	file, err := scanFile(r.DB.QueryRowContext(ctx, query, args...))
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("file not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to update file: %w", err)
	}

	return file, nil
}
func (r *mutationResolver) DeleteFile(ctx context.Context, id uuid.UUID, removeFromStorage *bool) (bool, error) {
	currentUser := auth.UserFromContext(ctx)
	if currentUser == nil {
		return false, fmt.Errorf("unauthorized")
	}

	// Get file info first if we need to delete from storage
	if removeFromStorage != nil && *removeFromStorage {
		var storagePath string
		err := r.DB.QueryRowContext(ctx,
			"SELECT storage_path FROM files WHERE id = $1 AND user_id = $2",
			id, currentUser.ID).Scan(&storagePath)
		if err != nil {
			return false, fmt.Errorf("file not found")
		}

		// Delete from storage (you'll need to implement this with your Storage instance)
		// For now, we'll just delete the DB record
	}

	query := `DELETE FROM files WHERE id = $1 AND user_id = $2`
	result, err := r.DB.ExecContext(ctx, query, id, currentUser.ID)
	if err != nil {
		return false, fmt.Errorf("failed to delete file: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return false, fmt.Errorf("failed to check deletion: %w", err)
	}

	return rows > 0, nil
}
func (r *mutationResolver) CreateDirectory(ctx context.Context, path string) (*model.Directory, error) {
	currentUser := auth.UserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Directories are created implicitly when files are added
	// Just return the directory structure
	return r.Directory(ctx, path)
}
func (r *mutationResolver) DeleteDirectory(ctx context.Context, path string, recursive *bool) (bool, error) {
	currentUser := auth.UserFromContext(ctx)
	if currentUser == nil {
		return false, fmt.Errorf("unauthorized")
	}

	isRecursive := false
	if recursive != nil {
		isRecursive = *recursive
	}

	if isRecursive {
		// Delete all files in directory and subdirectories
		pattern := path
		if !strings.HasSuffix(pattern, "/") {
			pattern += "/"
		}
		pattern += "%"

		query := `DELETE FROM files WHERE user_id = $1 AND (directory = $2 OR directory LIKE $3)`
		_, err := r.DB.ExecContext(ctx, query, currentUser.ID, path, pattern)
		if err != nil {
			return false, fmt.Errorf("failed to delete directory: %w", err)
		}
	} else {
		// Only delete if empty
		countQuery := `SELECT COUNT(*) FROM files WHERE user_id = $1 AND directory = $2`
		var count int
		err := r.DB.QueryRowContext(ctx, countQuery, currentUser.ID, path).Scan(&count)
		if err != nil {
			return false, fmt.Errorf("failed to check directory: %w", err)
		}

		if count > 0 {
			return false, fmt.Errorf("directory not empty")
		}
	}

	return true, nil
}
func (r *mutationResolver) MoveFile(ctx context.Context, id uuid.UUID, newDirectory string) (*model.File, error) {
	currentUser := auth.UserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	query := `UPDATE files SET directory = $1, updated_at = NOW()
	          WHERE id = $2 AND user_id = $3
	          RETURNING id, user_id, filename, directory, original_filename, mime_type,
	          file_size, telegram_file_id, telegram_file_unique_id, telegram_message_id,
	          storage_path, tags, description, created_at, updated_at`

	file, err := scanFile(r.DB.QueryRowContext(ctx, query, newDirectory, id, currentUser.ID))
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("file not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to move file: %w", err)
	}

	return file, nil
}
func (r *queryResolver) Files(ctx context.Context, filter *model.FileFilter, limit *int, offset *int) (*model.FileConnection, error) {
	currentUser := auth.UserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	limitVal := 50
	if limit != nil {
		limitVal = *limit
	}
	offsetVal := 0
	if offset != nil {
		offsetVal = *offset
	}

	// Build query with filters
	query := `SELECT id, user_id, filename, directory, original_filename, mime_type,
	          file_size, telegram_file_id, telegram_file_unique_id, telegram_message_id,
	          storage_path, tags, description, created_at, updated_at
	          FROM files WHERE user_id = $1`
	args := []interface{}{currentUser.ID}
	argCount := 1

	if filter != nil {
		if filter.Directory != nil {
			argCount++
			query += fmt.Sprintf(" AND directory = $%d", argCount)
			args = append(args, *filter.Directory)
		}
		if filter.MimeType != nil {
			argCount++
			query += fmt.Sprintf(" AND mime_type = $%d", argCount)
			args = append(args, *filter.MimeType)
		}
		if filter.SearchQuery != nil {
			argCount++
			query += fmt.Sprintf(" AND (filename ILIKE $%d OR description ILIKE $%d)", argCount, argCount)
			args = append(args, "%"+*filter.SearchQuery+"%")
		}
		if filter.Tags != nil && len(filter.Tags) > 0 {
			argCount++
			query += fmt.Sprintf(" AND tags && $%d", argCount)
			args = append(args, pq.Array(filter.Tags))
		}
	}

	// Count total
	countQuery := strings.Replace(query, "SELECT id, user_id, filename, directory, original_filename, mime_type, file_size, telegram_file_id, telegram_file_unique_id, telegram_message_id, storage_path, tags, description, created_at, updated_at", "SELECT COUNT(*)", 1)
	var totalCount int
	err := r.DB.QueryRowContext(ctx, countQuery, args...).Scan(&totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to count files: %w", err)
	}

	// Add ordering and pagination
	query += " ORDER BY created_at DESC"
	argCount++
	query += fmt.Sprintf(" LIMIT $%d", argCount)
	args = append(args, limitVal)
	argCount++
	query += fmt.Sprintf(" OFFSET $%d", argCount)
	args = append(args, offsetVal)

	rows, err := r.DB.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query files: %w", err)
	}
	defer rows.Close()

	files := []*model.File{}
	for rows.Next() {
		file, err := scanFile(rows)
		if err != nil {
			return nil, err
		}
		files = append(files, file)
	}

	hasMore := (offsetVal + len(files)) < totalCount

	return &model.FileConnection{
		Nodes:      files,
		TotalCount: totalCount,
		HasMore:    hasMore,
	}, nil
}
func (r *queryResolver) File(ctx context.Context, id uuid.UUID) (*model.File, error) {
	currentUser := auth.UserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	query := `SELECT id, user_id, filename, directory, original_filename, mime_type,
	          file_size, telegram_file_id, telegram_file_unique_id, telegram_message_id,
	          storage_path, tags, description, created_at, updated_at
	          FROM files WHERE id = $1 AND user_id = $2`

	file, err := scanFile(r.DB.QueryRowContext(ctx, query, id, currentUser.ID))
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("file not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to query file: %w", err)
	}

	return file, nil
}
func (r *queryResolver) Directories(ctx context.Context, parentPath *string) ([]*model.Directory, error) {
	currentUser := auth.UserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	parent := "/"
	if parentPath != nil {
		parent = *parentPath
	}

	// Get subdirectories
	query := `SELECT DISTINCT directory FROM files
	          WHERE user_id = $1 AND directory LIKE $2
	          ORDER BY directory`

	pattern := parent
	if !strings.HasSuffix(pattern, "/") {
		pattern += "/"
	}
	pattern += "%"

	rows, err := r.DB.QueryContext(ctx, query, currentUser.ID, pattern)
	if err != nil {
		return nil, fmt.Errorf("failed to query directories: %w", err)
	}
	defer rows.Close()

	dirMap := make(map[string]bool)
	for rows.Next() {
		var dir string
		if err := rows.Scan(&dir); err != nil {
			return nil, err
		}
		// Extract immediate subdirectory
		rel := strings.TrimPrefix(dir, parent)
		rel = strings.TrimPrefix(rel, "/")
		parts := strings.Split(rel, "/")
		if len(parts) > 0 && parts[0] != "" {
			subdir := filepath.Join(parent, parts[0])
			dirMap[subdir] = true
		}
	}

	directories := []*model.Directory{}
	for dir := range dirMap {
		// Count files in this directory
		countQuery := `SELECT COUNT(*) FROM files WHERE user_id = $1 AND directory = $2`
		var fileCount int
		err := r.DB.QueryRowContext(ctx, countQuery, currentUser.ID, dir).Scan(&fileCount)
		if err != nil {
			fileCount = 0
		}

		// Get subdirectories
		subQuery := `SELECT DISTINCT directory FROM files WHERE user_id = $1 AND directory LIKE $2`
		subPattern := dir
		if !strings.HasSuffix(subPattern, "/") {
			subPattern += "/"
		}
		subPattern += "%"

		subRows, err := r.DB.QueryContext(ctx, subQuery, currentUser.ID, subPattern)
		subdirs := []string{}
		if err == nil {
			defer subRows.Close()
			subDirMap := make(map[string]bool)
			for subRows.Next() {
				var subDir string
				if err := subRows.Scan(&subDir); err == nil {
					rel := strings.TrimPrefix(subDir, dir)
					rel = strings.TrimPrefix(rel, "/")
					parts := strings.Split(rel, "/")
					if len(parts) > 0 && parts[0] != "" {
						subDirMap[parts[0]] = true
					}
				}
			}
			for s := range subDirMap {
				subdirs = append(subdirs, s)
			}
		}

		parentDir := parent
		if dir == "/" {
			parentDir = ""
		}

		directories = append(directories, &model.Directory{
			Path:           dir,
			Parent:         &parentDir,
			Subdirectories: subdirs,
			FileCount:      fileCount,
		})
	}

	return directories, nil
}
func (r *queryResolver) Directory(ctx context.Context, path string) (*model.Directory, error) {
	currentUser := auth.UserFromContext(ctx)
	if currentUser == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Count files in this directory
	countQuery := `SELECT COUNT(*) FROM files WHERE user_id = $1 AND directory = $2`
	var fileCount int
	err := r.DB.QueryRowContext(ctx, countQuery, currentUser.ID, path).Scan(&fileCount)
	if err != nil {
		fileCount = 0
	}

	// Get subdirectories
	subQuery := `SELECT DISTINCT directory FROM files WHERE user_id = $1 AND directory LIKE $2`
	pattern := path
	if !strings.HasSuffix(pattern, "/") {
		pattern += "/"
	}
	pattern += "%"

	rows, err := r.DB.QueryContext(ctx, subQuery, currentUser.ID, pattern)
	subdirs := []string{}
	if err == nil {
		defer rows.Close()
		subDirMap := make(map[string]bool)
		for rows.Next() {
			var dir string
			if err := rows.Scan(&dir); err == nil {
				rel := strings.TrimPrefix(dir, path)
				rel = strings.TrimPrefix(rel, "/")
				parts := strings.Split(rel, "/")
				if len(parts) > 0 && parts[0] != "" {
					subDirMap[parts[0]] = true
				}
			}
		}
		for s := range subDirMap {
			subdirs = append(subdirs, s)
		}
	}

	// Get parent directory
	parentDir := "/"
	if path != "/" {
		parentDir = filepath.Dir(path)
	}

	return &model.Directory{
		Path:           path,
		Parent:         &parentDir,
		Subdirectories: subdirs,
		FileCount:      fileCount,
	}, nil
}
*/

// Helper function to scan a reminder from database rows
func scanReminder(scanner interface{ Scan(...interface{}) error }) (*model.Reminder, error) {
	var reminder model.Reminder
	var description, repeatRule sql.NullString
	var completedAt, repeatEnd sql.NullTime
	var eventID uuid.NullUUID
	var notificationChannels, tags pq.StringArray
	var reminderTimes pq.Int64Array

	err := scanner.Scan(
		&reminder.ID,
		&reminder.UserID,
		&reminder.Title,
		&description,
		&reminder.DueTime,
		&reminder.Completed,
		&completedAt,
		&reminder.Priority,
		&reminder.RepeatPattern,
		&repeatRule,
		&repeatEnd,
		&eventID,
		&notificationChannels,
		&reminderTimes,
		&tags,
		&reminder.CreatedAt,
		&reminder.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	// Handle nullable fields
	if description.Valid {
		reminder.Description = &description.String
	}
	if repeatRule.Valid {
		reminder.RepeatRule = &repeatRule.String
	}
	if completedAt.Valid {
		reminder.CompletedAt = &completedAt.Time
	}
	if repeatEnd.Valid {
		reminder.RepeatEnd = &repeatEnd.Time
	}
	if eventID.Valid {
		reminder.EventID = &eventID.UUID
	}

	// Handle array fields
	reminder.NotificationChannels = notificationChannels
	reminder.Tags = tags
	
	// Convert Int64Array to []int
	reminder.ReminderTimes = make([]int, len(reminderTimes))
	for i, v := range reminderTimes {
		reminder.ReminderTimes[i] = int(v)
	}

	return &reminder, nil
}
